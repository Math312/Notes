# 设计模式

设计模式不算是一门专门的学问，而是编码者经过长期的编码而总结出的一系列问题的解决思路。为什么要使用这些解决思路解决问题，而不是传统的思路解决呢？关键就是`解耦`。这里我们先解释两个名词：解耦和耦合性。

这里举一个简单的例子，假如我们现在有一个汽车类（Car），示例如下：

```java
class Car {
    String color = "RED";

    int size = 20;

    String name = "car";
}
```

接下来，我们要求，对于这个Car类型的对象，会根据不同的条件来对该对象进行不同的处理，例如：

1. 如果Car的color为Red，那么就将它的颜色变为Blue；
2. 如果Car的size小于10，那么就将其加倍
3. 如果Car的名字是car，就将其命名为BigCar

通常情况下我们可能会采用如下的代码进行处理：

```java
public class Main {

    public static void main(String[] args) {
        Car car = new Car();
        if (car.color.equals("RED")) {
            ...
        }
        if (car.size < 10) {
            ...
        }
        if (car.name.equals("car")) {
            ...
        }
        System.out.println(car);
    }
}
```

这段代码可以非常简洁的完成我们上述的需求，然而却有一个问题，如果此时，我们的需求增加了一项：

4. 如果Car的颜色为Yello，那么将其变为Red

那么此时，如果用传统的方法，那么你就要新增一条if语句，代码如下：

```java
public class Main {

    public static void main(String[] args) {
        Car car = new Car();
        if (car.color.equals("RED")) {
            ...
        }
        if (car.size < 10) {
            ...
        }
        if (car.name.equals("car")) {
            ...
        }
        if (car.color.equals("Yello")) {
            ...
        }
        System.out.println(car);
    }
}
```

这就意味着我们每添加一条需求就要修改一下实现代码，添加一个if语句，这样实现明显不是那么优雅，因为上述代码将业务实现与代码紧密耦合起来了。这里可能还没有了解到耦合的含义，这里我们将业务实现与代码解耦进行比较。

同样是上述的业务，将处理逻辑提取出来，单独作为一个类，这里将该类叫做Processor：

```java
public interface Processor {
    // 当该方法返回true时执行process(Car)方法
    boolean support(Car car);
    // 真正的处理逻辑
    void process(Car car);
}
```

处理`如果Car的color为Red，那么就将它的颜色变为Blue`请求的Processor实现如下：

```java
public class ColorRedProcessor implements Processor {
    public boolean support(Car car) {
        return car.color.equals("RED");
    }

    public void process(Car car) {
        car.color = "Blue";
    }
}
}
```

其余逻辑的实现这里省略。

如果使用这种方式处理刚才的业务请求，Main函数实现如下：

```java
public class Main {

    public static void main(String[] args) {
        Car car = new Car();
        List<Processor> list = new ArrayList<>();
        list.add(new ColorRedProcessor());
        ...
        for(Processor processor: list) {
            if (processor.support(car)) {
                processor.process(car);
            }
        }
        System.out.println(car);
    }
}
```

如果要添加一条新需求，只需创建一个新的Processor接口的实现类，然后将其加入到list中。

上述两种方法的区别是：第一种实现方法将业务逻辑的实现直接写在代码中，而第二种实现则将业务逻辑的具体实现封装在了一个Processor中，真正调用时使用的是Processor而不是具体的实现，做到了具体实现与抽象接口的解耦。耦合性简单的讲就是两个物体关联特别密切，一旦一个进行了修改，另一个必须做出更改的性质。而解耦就是要将两个物体的关系拆开。

##  设计模式六大原则

实际上设计模式只是在一定情况下，一些问题的解决方案，而我们不应仅仅拘束在这些方案中。设计模式共二十三种，这二十三种并不能完全满足我们业务开发的所有要求。因此，我们应该学习到设计模式的本质，也就是如下的六个原则：

1. 开闭原则：对扩展开放，对修改关闭

    这里我们先不考虑代码开发，首先考虑真实的产品。在日常生活中，我们都能观察到这样一个情景：一个软件的新版本是兼容之前的版本的，旧功能很少更改，新功能在旧功能的基础上进行添加。代码开发也一样，对扩展开放的意思比较好理解，我们可以添加新的功能，但是对于旧的功能不能修改，因为旧的功能可能会被别的功能使用，因此，一旦修改了旧的功能，新的功能可能就没办法使用了。

    该原则是用于解决已经存在的耦合性。

2. 里氏替换原则：任何基类出现的地方，子类一定可以出现

    我们同样先从现实生活中的场景出发，理解这个原则。考虑职场中的一个情景，公司的一个职位，要求一个人会技术1，技术2，技术3，然后就可以胜任这个职位，当现在在这个职位工作的同事离职之后，我们可以找到一个同样会上面3个技术的人就可以胜任这个职位。而如果这个职位只有你可以胜任，因为这个职位要求必须是董事长的儿子，那么当你离职之后，就没有人可以负责处理你的工作了，公司就会有很大的损失。

    上面例子中，我们所说的会技术1、2、3的人就是基类，而在这个职位的同事就是子类，因此，如果基类出现的地方，子类一定可以出现，就表示功能与具体实现做到了解耦，无论怎样的实现，只要能完成工作，就对功能的完成没有影响。

3. 