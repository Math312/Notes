# 15. 三数之和

## 问题

给你一个整数数组nums，判断是否存在三元组 [nums[i], nums[j], nums[k]]满足i!=j、i!=k 且 j!=k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

例子1：

```java
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

## 思路

对于该问题，最简单的方法是暴力法，时间复杂度为O(n^3)。但是暴力法也有一个问题，即结果的去重问题，例子1中有两个[-1]，因此会有至少两个重复解：

- [-1, 0 ,1]

解决该问题的常见方法是哈希表，然而该方法的缺点如下：

1. 耗费空间
2. 对于复杂数据结构不方便构建哈希表

因此，本题利用了另一种去重方法，排序。

对于该问题，例如：

[-1, -1, 0, 2, 1]

对于该例子，针对第一个-1，如果我们遍历过了所有三数之和的情况，那么第二个-1则不需要处理了。

那么接下来就将问题的去重部分简化了，但是如何合理的查找所有的序列呢？例如对于第一个-1，难道要对[-1,0,2,1]这个子数组进行O(n^2)的遍历么？其实这里还有重复的问题，我们需要寻找另一个排序方式去重。

这里我们构建一个递增序列：

1. 记我们当前正在处理的三元组中第一个值S[0]的index = i，因此，S[1]和S[2]的值从[i+1 :]子数组中取出
2. 注意[i+1 :]子数组已经进行了从小到大的排序
3. 取Left = i + 1, Right = n - 1(n 为输入数组长度)，
   1. 如果nums[Left]+nums[Right]+nums[i] > 0，证明nums[Left]+nums[Right]过大，只需要Right -- 就保证了该值递减
   2. 如果nums[Left]+nums[Right]+nums[i] < 0，证明nums[Left]+nums[Right]过小，只需要Left ++ 就保证了该值递增
   3. 如果遇到了重复值，只需要处理第一个值，其余的跳过即可



## 代码实现

```go

import "sort"

func threeSum(nums []int) [][]int {
	result := [][]int{}
    // 排序
	sort.Ints(nums)
	for i := 0; i < len(nums)-2; i++ {
		// 外部去重
        if i-1 >= 0 && nums[i-1] == nums[i] {
			continue
		}
		sum := -nums[i]
		left := i + 1
		right := len(nums) - 1
		for left < right {
			temp := nums[left] + nums[right]
			if temp == sum {
				result = append(result, []int{nums[i], nums[left], nums[right]})
				// 内部去重
                for left < right && nums[left] == nums[left+1] {
					left++
				}
                // 内部去重
				for left < right && nums[right] == nums[right-1] {
					right--
				}
				left++
				right--
			} else if temp > sum {
				right--
			} else {
				left++
			}
		}
	}
	return result
}
```

