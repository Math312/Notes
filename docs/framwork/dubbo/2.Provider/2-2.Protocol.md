# Protocol

通过[Provider](./2.Provider.md)这篇文章，我们了解到，Dubbo服务暴露通过`ServiceConfig.export()`方法进行暴露，真正暴露到外部，而暴露到远程服务时有两种方式：

1. 暴露到服务注册中心
2. 直连方式暴露

暴露到服务注册中心时由`RegistryProtocol.export()`与服务注册中心进行交互，而直连方式暴露时由`业务协议.export()`进行服务暴露。

其实暴露到服务注册中心的处理逻辑包含直连方式的处理逻辑，因此，为了较为清晰的拆解这个问题，笔者先介绍直连方式暴露服务的逻辑，再介绍暴露到服务注册中心的逻辑。

## 直连方式暴露

通过直连方式暴露服务运行的是`ServiceConfig.doExportUrlsFor1Protocol(...)`中的这部分逻辑：

```java
Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
DelegateProviderMetaDataInvoke wrapperInvoker = newDelegateProviderMetaDataInvoke(invoker, this);
Exporter<?> exporter =protocol.export(wrapperInvoker;
exporters.add(exporter);
```

其中ProxyFactory生成Invoker的相关逻辑请参考[2-1.ProxyFactory](./2-1.ProxyFactory.md)。这里主要介绍

```java
Exporter<?> exporter =protocol.export(wrapperInvoker;
```

经过之前的分析，我们知道这里的`protocol`是一个自适应代理，具体调用的`Protocol`实现取决于`wrapperInvoker.getUrl()`获取到的URL的具体协议，按照笔者提供的例子，这里的URL应为：

```
dubbo://192.168.12.64:20880/com.books.dubbo.demo.api.GreetingService?anyhost=true&application=first-dubbo-provider&bind.ip=192.168.12.64&bind.port=20880&default.deprecated=false&default.dynamic=false&default.register=true&deprecated=false&dubbo=2.0.2&dynamic=false&generic=false&group=dubbo&interface=com.books.dubbo.demo.api.GreetingService&methods=sayHello,testGeneric&pid=4385&register=true&release=2.7.1&revision=1.0.0&side=provider&timestamp=1610713667487&version=1.0.0
```

即服务URL。可以看到，协议名为dubbo，参考SPI配置文件`org.apache.dubbo.rpc.Protocol`：

```java
dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol
```

自适应代理将调用逻辑最后交给`DubboProtocol`处理，即这里调用的是`DubboProtocol.export(Invoker<T> invoker)`方法。

