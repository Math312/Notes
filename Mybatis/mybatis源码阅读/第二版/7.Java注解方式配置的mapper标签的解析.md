# 7.Java注解方式配置的mapper标签的解析

解析`<mappers>`标签时，我们说过，Mybatis中`Mapper`接口的配置方式有两种，一种是xml文件配置，就是上一节解释的那种。另一种是基于Java注解方式的配置，这种配置的解析由`MapperRegistry.addMapper(Class<T> type)`处理。

同样给出一个Java注解方式配置mapper的例子：

```java
@Insert("insert into table3 (id, name) values(#{nameId}, #{name})")
@SelectKey(statement="call next value for TestSequence", keyProperty="nameId", before=true, resultType=int.class)
int insertTable3(Name name);
```

关于更多Java注解方式配置`Mapper`接口的细节请查看如下文档：

[https://mybatis.org/mybatis-3/zh/java-api.html](https://mybatis.org/mybatis-3/zh/java-api.html)

本节主要讨论基于Java注解配置的解析过程，即`MapperRegistry.addMapper(Class<T> type)`方法。

```java
public <T> void addMapper(Class<T> type) {
    // 如果Mapper类不是接口，则不解析
    if (type.isInterface()) {
      // 如果已经解析过也不解析
      if (hasMapper(type)) {
        throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
      }
      boolean loadCompleted = false;
      try {
        // 将Mapper标记为已被解析
        knownMappers.put(type, new MapperProxyFactory<T>(type));
        // 创建MapperAnnotationBuilder开始解析Class对象
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        // 解析
        parser.parse();
        loadCompleted = true;
      } finally {
        // 解析失败，则从已解析注册表中删除该Class对象
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }
```

上面的代码有3点需要注意：

1. Mapper必须是接口，不能是类：这是因为Mybatis使用的是Java动态代理，是基于接口的，而不是基于子类的，因此如果不是接口，则无法正常使用。
2. 先将Mapper标记为已解析，再进行真正的解析操作：阅读了上一节文章应该清楚，XML文件解析过后会查找对应的Class对象进行再次解析，而对对应的Class对象进行解析正是通过这个方法，这里先剧透一下，Class对象解析时也会先解析对应的XML文件，因此，如果这里不进行先标记，就会造成死循环。
3. 解析完成的接口会被放入`knownMappers`注册表中，该注册表是`Map<Class<?>, MapperProxyFactory<?>>`类型的，其中key是`解析的Class对象`，value是一个`MapperProxyFactory<T>`，T就是key表示的类型。由value的类型我们也可以看出，`真正的Mapper对象是由动态代理实现的，至于具体怎么实现的，之后再看`。
4. Mapper接口的解析是通过`MapperAnnotationBuilder`。需要注意，`MapperAnnotationBuilder`并不是BaseBuilder的子类。而是单独的一个工具类，用于进行`基于注解的Mapper配置的解析`。

接下来让我们分析`MapperAnnotationBuilder`这个类，毕竟它是注解配置的解析类，依旧首先查看该类的属性：

```java
// Mybatis提供了@Insert\@Select\@Update\@Delete来替代XML配置中的对应标签
// 这里就是保存这些注解的地方
private static final Set<Class<? extends Annotation>> SQL_ANNOTATION_TYPES = new HashSet<>();
// Mybatis提供了@InsertProvider\@SelectProvider\@UpdateProvider\@DeleteProvider来提供XML配置中动态SQL的对应功能
private static final Set<Class<? extends Annotation>> SQL_PROVIDER_ANNOTATION_TYPES = new HashSet<>();

// 存储该SQL配置的Configuration对象
private final Configuration configuration;
// Mapper构建协助器，还是完成它构建复杂对象并将构建结果放入到Configuration对象中的任务
private final MapperBuilderAssistant assistant;
// 解析的Class对象
private final Class<?> type;
```

该类有两个静态块，用于初始化`SQL_ANNOTATION_TYPES`和`SQL_PROVIDER_ANNOTATION_TYPES`说实话就是把上面列出的8个注解分别存储在对应的位置。

根据`MapperRegistry.addMapper(Class<T> type)`方法代码可以看到，构建一个`MapperAnnotationBuilder`的代码如下：

```java
MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
```

同样根据`MapperRegistry.addMapper(Class<T> type)`方法中的如下代码：

```java
parser.parse();
```

可以看到，解析真正的解析逻辑在`MapperAnnotationBuilder.parse()`方法中。下面让我们主要研究该方法。

```java
public void parse() {
    String resource = type.toString();
    // 判断Mapper是否进行解析
    if (!configuration.isResourceLoaded(resource)) {
      // 解析XML配置
      loadXmlResource();
      // 将XML配置标记已经解析
      configuration.addLoadedResource(resource);
      // 设置当前命名空间
      assistant.setCurrentNamespace(type.getName());
      // 解析缓存
      parseCache();
      parseCacheRef();
      Method[] methods = type.getMethods();
      // 遍历接口声明的方法，如果不是桥接方法，则将其视为需要与SQL映射的方法
      // 对其进行解析
      for (Method method : methods) {
        try {
          // issue #237
          if (!method.isBridge()) {
            parseStatement(method);
          }
        } catch (IncompleteElementException e) {
          configuration.addIncompleteMethod(new MethodResolver(this, method));
        }
      }
    }
    // 解析未关联的方法
    parsePendingMethods();
}
```

可以看到，如果当前命名空间没有解析，无论怎样都会先进行XML文件的解析，然后再进行Java注解配置的解析。这里解析`XML文件配置`的方法是`loadXmlResource()方法`，考察该方法源码：

```java
private void loadXmlResource() {
    if (!configuration.isResourceLoaded("namespace:" + type.getName())) {
      // 获取XML配置文件名称
      // 默认情况下是权限定类名 将.换成/
      String xmlResource = type.getName().replace('.', '/') + ".xml";
      // 如果不能在当前目录中查找到
      // 就去类路径加载文件
      InputStream inputStream = type.getResourceAsStream("/" + xmlResource);
      if (inputStream == null) {
        // Search XML mapper that is not in the module but in the classpath.
        try {
          inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);
        } catch (IOException e2) {
          // ignore, resource is not required
        }
      }
      // 加载到文件后进行解析
      if (inputStream != null) {
        XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());
        xmlParser.parse();
      }
    }
}
```

所以说默认情况下，Mappper接口对应的XML配置文件在类路径的下面，并且相对路径是Mapper接口权限定类名转化过来的。最近有一个关系贼好的老哥，把`Mapper接口`与`Mapper.xml`都放在了java的一个包中，配置文件中的`<mappers>`标签是如下方式写的：

```xml
<mappers>
  <mapper class="fun.andre.mapper.UserMapper"/>
</mappers>
```

然后说怎么都找不到配置文件，这种当然找不到了，因为你将项目打包后配置文件就进入了你的jar包，根本不在类路径上啊，而在jar包里面。

因此建议乖乖写上XML配置文件位置，尽管你不写`Mapper`接口位置，其实问题也不大。
