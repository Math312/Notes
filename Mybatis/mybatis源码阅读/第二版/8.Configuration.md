# Configuration

在之前，我们已经对Mybatis的配置解析有了一定的了解。我们了解了非常重要的一点，Mybatis将所有的配置存在了一个Configuration对象中。而我们花费了如此长的事件分析一些解析配置的源码也就是这个目的：

让读者知道每个配置在Mybatis中到底表示什么？

了解了这些内容之后，我们才会在阅读源码的时候知道这段代码写到的东西从哪里获取。

本节的最后一章，我们将介绍一下这个Configuration类。系统的介绍一下这个类的属性。

其实在最开始解析Mybatis的Config配置时，我们就已经有倾向性的将Mybatis配置分为两类：

1. 配置相关的
2. 调用相关的

其中配置相关的就是`<settings>、<properties>`等标签设置的属性，而调用相关的就是`插件、Mapper`这一类。

在Configuration类中，也将属性分成了上面规定的两组，你可以在Configuration类的属性定义中看到如下注释：

```java
/**
   * Configuration factory class.
   * Used to create Configuration for loading deserialized unread properties.
   **/
```

其中该注释以上的就是我们说的第一类属性，该注释以下的就是我们说的第二类属性。

首先让我们查看第一类属性，其实这类属性大部分都可以在Mybatis配置文件中查找到直接对应的部分，尽管这部分比较枯燥，还是请读者耐心读完。

```java
  // Mybatis <environment>标签所指示的配置
  protected Environment environment;
  // Mybatis <settings>中可以设置的safeRowBoundsEnable属性
  // 标识是否允许在嵌套语句中分页
  protected boolean safeRowBoundsEnabled;
  // Mybatis <settings>中可以设置的safeResultHandlerEnabled属性
  // 标识是否允许在嵌套语句中使用结果处理器
  protected boolean safeResultHandlerEnabled = true;
  // Mybatis <settings>中可以设置的mapUnderscoreToCamelCase属性
  // 标识是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。
  protected boolean mapUnderscoreToCamelCase;
  // Mybatis <settings>中可以设置的aggressiveLazyLoading属性
  // 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载
  protected boolean aggressiveLazyLoading;
  // Mybatis <settings>中可以设置的multipleResultSetsEnabled属性
  // 是否允许单个语句返回多结果集
  protected boolean multipleResultSetsEnabled = true;
  // Mybatis <settings>中可以设置的useGeneratedKeys属性
  // 允许 JDBC 支持自动生成主键，需要数据库驱动支持。
  protected boolean useGeneratedKeys;
  // Mybatis <settings>中可以设置的useColumnLabel属性
  protected boolean useColumnLabel = true;
  // Mybatis <settings>中可以设置的cacheEnabled属性
  protected boolean cacheEnabled = true;
  // Mybatis <settings>中可以设置的callSettersOnNulls属性
  protected boolean callSettersOnNulls;
  // Mybatis <settings>中可以设置的useActualParamName属性
  protected boolean useActualParamName = true;
  // Mybatis <settings>中可以设置的returnInstanceForEmptyRow属性
  protected boolean returnInstanceForEmptyRow;

  // Mybatis <settings>中可以设置的logPrefix属性
  protected String logPrefix;
  // Mybatis <settings>中可以设置的logImpl属性
  protected Class<? extends Log> logImpl;
  // Mybatis <settings>中可以设置的vfsImpl属性
  protected Class<? extends VFS> vfsImpl;
  // Mybatis <settings>中可以设置的localCacheScope属性
  protected LocalCacheScope localCacheScope = LocalCacheScope.SESSION;
  protected JdbcType jdbcTypeForNull = JdbcType.OTHER;
  protected Set<String> lazyLoadTriggerMethods = new HashSet<>(Arrays.asList("equals", "clone", "hashCode", "toString"));
  protected Integer defaultStatementTimeout;
  protected Integer defaultFetchSize;
  protected ResultSetType defaultResultSetType;
  protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;
  protected AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;
  protected AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;

  protected Properties variables = new Properties();
  protected ReflectorFactory reflectorFactory = new DefaultReflectorFactory();
  protected ObjectFactory objectFactory = new DefaultObjectFactory();
  protected ObjectWrapperFactory objectWrapperFactory = new DefaultObjectWrapperFactory();

  protected boolean lazyLoadingEnabled = false;
  protected ProxyFactory proxyFactory = new JavassistProxyFactory(); // #224 Using internal Javassist instead of OGNL

  protected String databaseId;
```

具体的每个配置的功能可以查看Mybatis文档我们主要介绍下面的属性：

```java
  // 1. mapperRegistry
  // Mybatis的所有Mapper接口实现都存储在里面
  // 存储方式是一个HashMap，其中key是Class对象，value是对应的MapperProxyFactory，我们真正使用的Mapper就是MapperProxyFactory创造出来的
  protected final MapperRegistry mapperRegistry = new MapperRegistry(this);
  // 2. interceptorChain用于存储Mybatis插件
  // 内部实现是一个链表，用于存储插件实现
  protected final InterceptorChain interceptorChain = new InterceptorChain();
  // 3.
  protected final TypeHandlerRegistry typeHandlerRegistry = new TypeHandlerRegistry(this);
  protected final TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();
  protected final LanguageDriverRegistry languageRegistry = new LanguageDriverRegistry();

  protected final Map<String, MappedStatement> mappedStatements = new StrictMap<MappedStatement>("Mapped Statements collection")
      .conflictMessageProducer((savedValue, targetValue) ->
          ". please check " + savedValue.getResource() + " and " + targetValue.getResource());
  protected final Map<String, Cache> caches = new StrictMap<>("Caches collection");
  protected final Map<String, ResultMap> resultMaps = new StrictMap<>("Result Maps collection");
  protected final Map<String, ParameterMap> parameterMaps = new StrictMap<>("Parameter Maps collection");
  protected final Map<String, KeyGenerator> keyGenerators = new StrictMap<>("Key Generators collection");

  protected final Set<String> loadedResources = new HashSet<>();
  protected final Map<String, XNode> sqlFragments = new StrictMap<>("XML fragments parsed from previous mappers");

  protected final Collection<XMLStatementBuilder> incompleteStatements = new LinkedList<>();
  protected final Collection<CacheRefResolver> incompleteCacheRefs = new LinkedList<>();
  protected final Collection<ResultMapResolver> incompleteResultMaps = new LinkedList<>();
  protected final Collection<MethodResolver> incompleteMethods = new LinkedList<>();

  /*
   * A map holds cache-ref relationship. The key is the namespace that
   * references a cache bound to another namespace and the value is the
   * namespace which the actual cache is bound to.
   */
  protected final Map<String, String> cacheRefMap = new HashMap<>();
```
