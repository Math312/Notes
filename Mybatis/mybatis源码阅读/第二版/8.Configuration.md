# Configuration

在之前，我们已经对Mybatis的配置解析有了一定的了解。我们了解了非常重要的一点，Mybatis将所有的配置存在了一个Configuration对象中。而我们花费了如此长的事件分析一些解析配置的源码也就是这个目的：

让读者知道每个配置在Mybatis中到底表示什么？

了解了这些内容之后，我们才会在阅读源码的时候知道这段代码写到的东西从哪里获取。

本节的最后一章，我们将介绍一下这个Configuration类。系统的介绍一下这个类的属性。

其实在最开始解析Mybatis的Config配置时，我们就已经有倾向性的将Mybatis配置分为两类：

1. 配置相关的
2. 调用相关的

其中配置相关的就是`<settings>、<properties>`等标签设置的属性，而调用相关的就是`插件、Mapper`这一类。

在Configuration类中，也将属性分成了上面规定的两组，你可以在Configuration类的属性定义中看到如下注释：

```java
/**
   * Configuration factory class.
   * Used to create Configuration for loading deserialized unread properties.
   **/
```

其中该注释以上的就是我们说的第一类属性，该注释以下的就是我们说的第二类属性。

首先让我们查看第一类属性，其实这类属性大部分都可以在Mybatis配置文件中查找到直接对应的部分，尽管这部分比较枯燥，还是请读者耐心读完。

```java
  // Mybatis <environment>标签所指示的配置
  protected Environment environment;
  // Mybatis <settings>中可以设置的safeRowBoundsEnable属性
  // 标识是否允许在嵌套语句中分页
  protected boolean safeRowBoundsEnabled;
  // Mybatis <settings>中可以设置的safeResultHandlerEnabled属性
  // 标识是否允许在嵌套语句中使用结果处理器
  protected boolean safeResultHandlerEnabled = true;
  // Mybatis <settings>中可以设置的mapUnderscoreToCamelCase属性
  // 标识是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。
  protected boolean mapUnderscoreToCamelCase;
  // Mybatis <settings>中可以设置的aggressiveLazyLoading属性
  // 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载
  protected boolean aggressiveLazyLoading;
  // Mybatis <settings>中可以设置的multipleResultSetsEnabled属性
  // 是否允许单个语句返回多结果集
  protected boolean multipleResultSetsEnabled = true;
  // Mybatis <settings>中可以设置的useGeneratedKeys属性
  // 允许 JDBC 支持自动生成主键，需要数据库驱动支持。
  protected boolean useGeneratedKeys;
  // Mybatis <settings>中可以设置的useColumnLabel属性
  protected boolean useColumnLabel = true;
  // Mybatis <settings>中可以设置的cacheEnabled属性
  protected boolean cacheEnabled = true;
  // Mybatis <settings>中可以设置的callSettersOnNulls属性
  protected boolean callSettersOnNulls;
  // Mybatis <settings>中可以设置的useActualParamName属性
  protected boolean useActualParamName = true;
  // Mybatis <settings>中可以设置的returnInstanceForEmptyRow属性
  protected boolean returnInstanceForEmptyRow;

  // Mybatis <settings>中可以设置的logPrefix属性
  protected String logPrefix;
  // Mybatis <settings>中可以设置的logImpl属性
  protected Class<? extends Log> logImpl;
  // Mybatis <settings>中可以设置的vfsImpl属性
  protected Class<? extends VFS> vfsImpl;
  // Mybatis <settings>中可以设置的localCacheScope属性
  protected LocalCacheScope localCacheScope = LocalCacheScope.SESSION;
  protected JdbcType jdbcTypeForNull = JdbcType.OTHER;
  protected Set<String> lazyLoadTriggerMethods = new HashSet<>(Arrays.asList("equals", "clone", "hashCode", "toString"));
  protected Integer defaultStatementTimeout;
  protected Integer defaultFetchSize;
  protected ResultSetType defaultResultSetType;
  protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;
  protected AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;
  protected AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;

  protected Properties variables = new Properties();
  protected ReflectorFactory reflectorFactory = new DefaultReflectorFactory();
  protected ObjectFactory objectFactory = new DefaultObjectFactory();
  protected ObjectWrapperFactory objectWrapperFactory = new DefaultObjectWrapperFactory();

  protected boolean lazyLoadingEnabled = false;
  protected ProxyFactory proxyFactory = new JavassistProxyFactory(); // #224 Using internal Javassist instead of OGNL

  protected String databaseId;
```

具体的每个配置的功能可以查看Mybatis文档我们主要介绍下面的属性：

```java
  // 1. mapperRegistry
  // Mybatis的所有Mapper接口实现都存储在里面
  // 存储方式是一个HashMap，其中key是Class对象，value是对应的MapperProxyFactory，我们真正使用的Mapper就是MapperProxyFactory创造出来的
  protected final MapperRegistry mapperRegistry = new MapperRegistry(this);
  // 2. interceptorChain用于存储Mybatis插件
  // 内部实现是一个链表，用于存储插件实现
  protected final InterceptorChain interceptorChain = new InterceptorChain();
  // 3. typeHandlerRegistry用于存储所有的类型处理器
  // 内部实现是一个ConcurrentHashMap，用于存储类型与TypeHandler之间的关系
  protected final TypeHandlerRegistry typeHandlerRegistry = new TypeHandlerRegistry(this);
  // 4. typeAliasRegistry用于存储别名
  // 内部实现是一个HashMap，key是字符串，value是对应的别名
  protected final TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();
  // 5. languageRegistry用于存储语言驱动
  // 用于支持各种语言
  protected final LanguageDriverRegistry languageRegistry = new LanguageDriverRegistry();
  // 6. mappedStatements用于存储命名空间内的各种执行真正操作的SQL
  // 例如一个<insert>、一个<select>就对应一个MappedStatement
  // 其中key是SQL操作的id
  protected final Map<String, MappedStatement> mappedStatements = new StrictMap<MappedStatement>("Mapped Statements collection")
      .conflictMessageProducer((savedValue, targetValue) ->
          ". please check " + savedValue.getResource() + " and " + targetValue.getResource());
  // 缓存列表，Mybatis自定义了一个StrictMap
  // 该Map底层是HashMap，但是不能put重复的key
  // caches的key是命名空间，value是对应的缓存
  protected final Map<String, Cache> caches = new StrictMap<>("Caches collection");
  // 结果集列表
  // 该列表主要存储<selet>标签这种返回的结果集格式
  // 对应<resultMap>标签 key是id
  protected final Map<String, ResultMap> resultMaps = new StrictMap<>("Result Maps collection");
  // 参数集合列表
  // 该列表主要存储sql执行语句的输入集合
  // 对应<parameterMap>标签 key是id
  protected final Map<String, ParameterMap> parameterMaps = new StrictMap<>("Parameter Maps collection");
  // keyGenerator存储列表
  // 此处存放的都是用于存储自动生成key的KeyGenerator
  // 对应的是<selectKey>标签
  protected final Map<String, KeyGenerator> keyGenerators = new StrictMap<>("Key Generators collection");
  // 该属性用于存储已经解析过的资源
  // 避免循环依赖
  protected final Set<String> loadedResources = new HashSet<>();
  // 该属性用于存储可复用的sql段
  // 对应<sql>标签
  protected final Map<String, XNode> sqlFragments = new StrictMap<>("XML fragments parsed from previous mappers");

  // 如下三个属性用来存储解析过程中未完成解析的数据
  protected final Collection<XMLStatementBuilder> incompleteStatements = new LinkedList<>();
  protected final Collection<CacheRefResolver> incompleteCacheRefs = new LinkedList<>();
  protected final Collection<ResultMapResolver> incompleteResultMaps = new LinkedList<>();
  protected final Collection<MethodResolver> incompleteMethods = new LinkedList<>();
  // 该属性用于存储缓存间的关系
  // 对应<cache-ref>标签
  protected final Map<String, String> cacheRefMap = new HashMap<>();
```

到这里其实我们已经了解了Configuration对象中到底存储的是什么，以及如何将配置映射到Configuration对象中的。

最后让我们总结一下一整章的内容。

本章内容主要从SqlSessionFactory出发，介绍Mybatis配置解析的主要内容。这是Mybatis中最初始的一个步骤，也是理解Mybatis最为重要的一步，因为只有理解了基础数据结构才能理解代码的架构流程。

对于Mybatis来说，每个标签几乎都有他自己独特的解析器，当然也有几个标签共用一个的。

对于Mybatis的config配置文件，有XMLConfigBuilder进行解析。而对于Mybatis的Mapper映射文件，则交给了XMLMapperBuilder进行解析。而XMLMapperBuilder又调用了诸多的BaseBuilder子类对XML配置文件进行解析。

解析过后，最终呈现给我们的就是一个Configuration对象。这个对象存储着所有的配置。让我们可以通过查阅该对象，就可以完成接下来的所有任务。至此，我们完成了配置解析的所有工作。配置解析与映射完成后，就可以开始真正的业务操作了。下面让我们考虑Mapper对象到底是怎么生成，怎么运作的吧。
