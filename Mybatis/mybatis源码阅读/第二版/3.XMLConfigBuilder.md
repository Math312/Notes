# XMLConfigBuilder

根据上一节内容我们已经知道了，XML配置文件的解析全部是通过XMLConfigBuilder进行完成的，该类的类继承结构如下：

![XMLConfigBuilder类继承结构图](./XMLConfigBuilder类继承结构图.png)

其中BaseBuilder提供了一个配置解析器所需要的大部分工具方法，以及通用的变量、操作这些通用变量的方法。通用的变量分别如下：

1. Configuration：configuration，用于存储解析过程中用于担当解析结果的Configuration对象
2. TypeAliasRegistry: typeAliasRegistry，用于存储类型别名的注册表
3. TypeHandlerRegistry: typeHandlerRegistry，用于存储类型处理器的注册表

对于一个配置解析器来说，保存结果的对象肯定是必须的，剩下两个注册表分别是别名和类型处理器，这到底是谁通用的呢。我们考察`BaseBuilder`的子类，类图如下：

![BaseBuilder类继承结构图](BaseBuilder类继承结构图.png)

可以看到，`BaseBuilder`有7个子类，分别是：

1. XMLConfigBuilder：Mybatis xml配置解析器
2. XMLScriptBuilder：Mybatis 动态SQL标签解析器
3. XMLMapperBuilder：Mybatis mapper标签配置解析器
4. SqlSourceBuilder：Mybatis ParameterMap标签解析器
5. XMLStatementBuiler： Mybatis SQL语句解析器，解析insert、update、select标签
6. MapperBuilderAssistant：Mapper解析时的辅助缓存
7. ParameterMappingTokenHandler：parameterMapping的解析工具

由于别名注册表和类型处理器是除了配置文件外每个Mapper文件都要用的，因此，就把它放在了BaseBuilder中。除了XMLConfigBuilder以外所有的其他Builder都是为`<mapper>`服务的。

所以我们可以根据配置文件来对代码进行分析，首先分析Mybatis的基本配置解析，然后再分析`<mapper>`标签的配置解析。

首先让我们分析XMLConfigBuilder的解析Mybatis配置的逻辑：也就是`XMLConfigBuilder`的`parse()`方法：

```java
public Configuration parse() {
    // 处理重复解析问题
    if (parsed) {
      throw new BuilderException("Each XMLConfigBuilder can only be used once.");
    }
    parsed = true;
    // 解析configuration标签
    parseConfiguration(parser.evalNode("/configuration"));
    // 返回解析结果
    return configuration;
}
```

根据Mybatis文档可知，Mybatis配置文档层级结构如下：

- configuration（配置）
  - properties（属性）
  - settings（设置）
  - typeAliases（类型别名）
  - typeHandlers（类型处理器）
  - objectFactory（对象工厂）
  - plugins（插件）
  - environments（环境配置）
    - environment（环境变量）
      - transactionManager（事务管理器）
      - dataSource（数据源）
  - databaseIdProvider（数据库厂商标识）
  - mappers（映射器）

所以要从根节点`configuration`开始解析，具体解析逻辑在`parseConfiguration(XNode root)`方法中，该方法代码如下：

```java
private void parseConfiguration(XNode root) {
    try {
      //issue #117 read properties first
      // 解析properties标签
      propertiesElement(root.evalNode("properties"));
      // 解析settings标签
      Properties settings = settingsAsProperties(root.evalNode("settings"));
      loadCustomVfs(settings);
      // 解析typeAliases标签
      typeAliasesElement(root.evalNode("typeAliases"));
      // 解析plugins标签
      pluginElement(root.evalNode("plugins"));
      // 解析objectFactory标签
      objectFactoryElement(root.evalNode("objectFactory"));
      objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
      reflectorFactoryElement(root.evalNode("reflectorFactory"));
      settingsElement(settings);
      // 解析environments标签
      environmentsElement(root.evalNode("environments"));
      // 解析databaseIdProvier标签
      databaseIdProviderElement(root.evalNode("databaseIdProvider"));
      // 解析typeHandlers 标签
      typeHandlerElement(root.evalNode("typeHandlers"));
      // 解析mappers标签
      mapperElement(root.evalNode("mappers"));
    } catch (Exception e) {
      throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
    }
}
```

事实上根据方法名我们就可以知道哪个方法用于解析哪个标签。其实上面的几个标签的解析方法可以分为两类：

1. 仅仅解析标签的方法
2. 解析标签、创建标签功能处理器的方法

第一种方法仅仅解析XML文件标签中的内容，并将其存储到`Configuration`的对应配置中，他们分别是：

1. propertiesElement(XNode)
2. settingsAsProperties(XNode)
3. typeAliasesElement(XNode)
4. typeHandlerElement(XNode)

而第二类方法则不同，他们不仅仅解析标签，并根据标签创建对应的处理器，Mybatis正是使用这些处理器来处理对应的功能的，这些方法是：

1. pluginElement(XNode)
2. objectFactoryElement(XNode)
3. loadCustomVfs(Properties)
4. settingsElement(Properties)
5. objectWrapperFactoryElement(XNode)
6. reflectorFactoryElement(XNode)
7. environmentsElement(XNode)
8. databaseIdProviderElement(XNode)
9. mapperElement(XNode)

第二类方法中，最与众不同的就是`mappers标签`的解析方法`mapperElement(XNode)`，该方法应用上面所有的解析结果，创建了我们所使用的`Mapper`对象。

最后我们简单分析一下第一类方法，第二类方法我们下一节进行分析。这里我们首先查看`propertiesElement(XNode)`、`settingsAsProperties(XNode)`和`settingsElement(Properties)`三个方法，这三个方法都是简单直接的配置读取、配置设置方法。

首先查看`propertiesElement(XNode)`方法，该负责解析自定义属性，由于Mybatis支持自定义属性`properties`，因此`properties`标签必定是优先进行解析的，因此，该标签的解析就放在了第一位。该方法仅仅读取了`properties`标签中存储的属性，并将其设置到`configuration`和`解析器`的`variables`属性中，这是为了被其他标签引用。方法代码如下：

```java
private void propertiesElement(XNode context) throws Exception {
    if (context != null) {
      // 获取properties标签的子标签，即property标签，
      // 分别将其解析称为key-value形式，然后存储到Properties对象中
      Properties defaults = context.getChildrenAsProperties();
      // 如果有指定的本地资源目录，或者网络URL，则通过这里读取
      String resource = context.getStringAttribute("resource");
      String url = context.getStringAttribute("url");
      if (resource != null && url != null) {
        throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.");
      }
      // 然后对获取到的资源进行解析，并与刚才读取到的属性合并
      if (resource != null) {
        defaults.putAll(Resources.getResourceAsProperties(resource));
      } else if (url != null) {
        defaults.putAll(Resources.getUrlAsProperties(url));
      }
      // 如果Configuration对象具有默认的variables，则也将其进行合并
      Properties vars = configuration.getVariables();
      if (vars != null) {
        defaults.putAll(vars);
      }
      // 最后将解析完毕的properties放入到解析器和configuration的variables属性中
      parser.setVariables(defaults);
      configuration.setVariables(defaults);
    }
}
```

由于时间有限，第一部分其他的方法之后再进行补充，对于第二部分方法，我们优先分析插件解析与Mapper解析两部分，因为这两部分更加常用。
