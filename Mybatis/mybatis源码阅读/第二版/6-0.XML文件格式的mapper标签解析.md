# 6-0.XML文件格式的mapper标签解析

上一节已经知道，对于XML文件中`mapper`标签的解析都是通过`XMLMapperBuilder`进行处理的。

接下来让我们首先对`XMLMapperBuilder`进行分析，然后再详细考察`mapper`标签的解析逻辑。

## XMLMapperBuilder

`XMLMapperBuilder`，顾名思义，该工具类是用于解析`mapper`标签的，这里我们主要分析`XMLMapperBuilder`的四个属性，便于下面分析具体的业务逻辑。`XMLMapperBuilder`拥有如下四个属性：

1. XPathParser parser：XML文件解析器，该对象是XML文件解析的工具类。
2. MapperBuilderAssistant builderAssistant：Mapper构建协助器，由于Mybatis中的很多对象都比较大，属性比较多，而解析结果本身就是一个对象，因此Mybatis将解析结果的构建代码进行封装，封装到这个构建协助器里，让代码更加简洁。除此之外，这里还存储了当前的命名空间，方便获取。
3. Map<String, XNode> sqlFragments ：Sql段，这里我们先不考虑该对象含义
4. String resource：要解析的资源的名称

## 开始解析mapper标签

了解了XMLMapperBuilder的各个属性的含义，就可以开始解析`mapper`标签了，否则我们可能在解析到一半就不知道哪个东西是做什么的了。

根据`XMLConfigBuilder`的`mapperElement(XNode)`方法中如下代码：

```java
XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();
```

我们知道，`mapper`标签的解析是由`XMLMapperBuilder`的`parse()`方法完成的。让我们考察该方法代码：

```java
public void parse() {
    // 如果资源没有被解析过，则需要进行解析
    if (!configuration.isResourceLoaded(resource)) {
      configurationElement(parser.evalNode("/mapper"));
      configuration.addLoadedResource(resource);
      bindMapperForNamespace();
    }
    // 解析未完成解析的ResultMap、CacheRef和Statement
    parsePendingResultMaps();
    parsePendingCacheRefs();
    parsePendingStatements();
}
```

对于该方法的前半部分肯定大家都没有意见，如果资源没有被解析，就开始解析，这是一个正常的需求，而后半部分，则就无法理解了，为什么这里无论如何都要执行呢？事实上，并不是解析了一个`mapper`配置文件就可以获取到所有的`ResultMap`、`CacheRef`和`Statements`的，所以再每次解析完一个`mapper`配置文件都会进行解析一遍上面三个资源，而且，对于具有Java配置的Mybatis，可能还需要解析完Java配置后，再去解析上面的三个资源。所以才会出现后半部分。

让我们先讨论前半部分的解析`mapper`标签的部分。其中：

1. `configurationElement(parser.evalNode("/mapper"))` 这行代码负责主要解析mapper配置，并创建一个`MappedStatement`放入到`Configuration`类型的对象中。
2. `configuration.addLoadedResource(resource);` 这行代码负责记录，该配置文件已经被解析完毕
3. `bindMapperForNamespace();` 最后的一行代码负责将Java的`Mapper`对象与命名空间（即XML配置文件）联系起来。

### 解析mapper标签

下面让我们考察一下`configurationElement(XNode)`方法。该方法是解析`XML映射文件`的主要逻辑。代码如下：

```java
private void configurationElement(XNode context) {
    try {
      // 获取命名空间名称
      String namespace = context.getStringAttribute("namespace");
      if (namespace == null || namespace.equals("")) {
        throw new BuilderException("Mapper's namespace cannot be empty");
      }
      // 存储当前命名空间
      builderAssistant.setCurrentNamespace(namespace);
      // 解析另一命名空间的缓存配置
      cacheRefElement(context.evalNode("cache-ref"));
      // 解析当前命名空间是否开启缓存
      cacheElement(context.evalNode("cache"));
      // 解析parameterMap标签
      parameterMapElement(context.evalNodes("/mapper/parameterMap"));
      // 解析resultMap标签
      resultMapElements(context.evalNodes("/mapper/resultMap"));
      // 解析sql标签
      sqlElement(context.evalNodes("/mapper/sql"));
      // 解析select|insert|update|delete标签
      buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
    } catch (Exception e) {
      throw new BuilderException("Error parsing Mapper XML. The XML location is '" + resource + "'. Cause: " + e, e);
    }
}
```

#### 解析cache-ref标签

首先处理`<cache-ref>`标签，该标签是引用其他缓存的标签，Mybatis对该标签描述如下：

```java
对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新。 但你可能会想要在多个命名空间中共享相同的缓存配置和实例。要实现这种需求，你可以使用 cache-ref 元素来引用另一个缓存。
```

该属性的解析由`cacheRefElement(XNode)`方法处理，其实代码很简单：

```java
private void cacheRefElement(XNode context) {
    if (context != null) {
      // 在Configuration的缓存引用注册表中添加一条
      // 当前命名空间：要引用的命名空间
      // 用于标识命名空间缓存之间的引用关系
      configuration.addCacheRef(builderAssistant.getCurrentNamespace(), context.getStringAttribute("namespace"));
      // 将builderAssistant和要引用的命名空间缓存封装入一个CacheRefResolver去解析缓存
      // 解析成功后放到builderAssistant备用
      CacheRefResolver cacheRefResolver = new CacheRefResolver(builderAssistant, context.getStringAttribute("namespace"));
      try {
        // 尝试解析缓存
        // 解析失败则放入到Configuration对象的incompleteCacheRefs注册表中
        cacheRefResolver.resolveCacheRef();
      } catch (IncompleteElementException e) {
        configuration.addIncompleteCacheRef(cacheRefResolver);
      }
    }
}
```

事实证明，在Mybatis中，储存命名空间使用缓存关系的是一张名为`cacheRefMap`格式为`<String,String>`的注册表，其中key和value都是命名空间的名称。因此此处，是将`<当前命名空间，引用的缓存的命名空间>`放入到注册表中。然后再根据缓存命名空间解析使用的缓存。

当然对于解析失败的缓存，Mybatis将解析失败，即当前未生成的缓存，就将其放入到`incompleteCacheRefs`注册表中，等待进一步解析，这也就是`mapper`标签解析中后三个方法的意义。

#### 解析cache标签

`<cache>`标签用于定义当前命名空间使用的缓存，该标签的解析是由`cacheElement(XNode)`方法完成的。解析方法相对简单：

```java
private void cacheElement(XNode context) {
    if (context != null) {
      // 获取缓存类型
      // 默认情况下是永久缓存，没有过期时间
      String type = context.getStringAttribute("type", "PERPETUAL");
      Class<? extends Cache> typeClass = typeAliasRegistry.resolveAlias(type);
      // 解析过期策略，默认是LRU，最近最少使用
      String eviction = context.getStringAttribute("eviction", "LRU");
      Class<? extends Cache> evictionClass = typeAliasRegistry.resolveAlias(eviction);
      // 设置刷新间隔
      Long flushInterval = context.getLongAttribute("flushInterval");
      // 设置缓存大小
      Integer size = context.getIntAttribute("size");
      // 设置缓存是否只读
      boolean readWrite = !context.getBooleanAttribute("readOnly", false);
      boolean blocking = context.getBooleanAttribute("blocking", false);
      // 将所有属性按照Properties读取
      Properties props = context.getChildrenAsProperties();
      // 将读取到的属性应用到缓存中，构建缓存
      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
    }
}
```

之前说过，`MapperBuilderAssistant`的一大功能就是创建复杂对象并注册到`Configuration`注册表中，这里就是通过读取到的属性建立一个缓存，然后注册到Configuration对象中。查看`MapperBuilderAssistant.useNewCache(...)`方法：

```java
public Cache useNewCache(Class<? extends Cache> typeClass,
      Class<? extends Cache> evictionClass,
      Long flushInterval,
      Integer size,
      boolean readWrite,
      boolean blocking,
      Properties props) {
    // 根据配置构建Cache
    // 默认状态是永久缓存，使用LRU算法
    Cache cache = new CacheBuilder(currentNamespace)
        .implementation(valueOrDefault(typeClass, PerpetualCache.class))
        .addDecorator(valueOrDefault(evictionClass, LruCache.class))
        .clearInterval(flushInterval)
        .size(size)
        .readWrite(readWrite)
        .blocking(blocking)
        .properties(props)
        .build();
    // 将缓存注册到Configuration中
    configuration.addCache(cache);
    currentCache = cache;
    return cache;
}
```

那么在Mybatis中，缓存是如何存储的呢？考察如下代码：

```java
configuration.addCache(cache);

public void addCache(Cache cache) {
    caches.put(cache.getId(), cache);
}
```

可以看到，缓存在Configuration对象中也是存放在一个注册表中，该注册表叫做`caches`，格式是`<String, Cache>`，其中key是命名空间，value是缓存实例。

#### 解析parameterMap标签

`<parameterMap>`标签用于声明方法参数类型，解析该标签使用的是`parameterMapElement(List<XNode>)`方法，考察该方法：

```java
private void parameterMapElement(List<XNode> list) {
    // 遍历所有parameterMap标签
    for (XNode parameterMapNode : list) {
      // 获取parameterMap的id
      String id = parameterMapNode.getStringAttribute("id");
      // 获取parameterMap代表的Class类型
      String type = parameterMapNode.getStringAttribute("type");
      // 将type解析为Class对象
      Class<?> parameterClass = resolveClass(type);
      // 获取所有parameter子标签
      List<XNode> parameterNodes = parameterMapNode.evalNodes("parameter");
      // 创建列表存储子标签内容
      List<ParameterMapping> parameterMappings = new ArrayList<>();
      // 遍历所有子标签
      for (XNode parameterNode : parameterNodes) {
        // 获取属性名
        String property = parameterNode.getStringAttribute("property");
        // 获取属性类型
        String javaType = parameterNode.getStringAttribute("javaType");
        // 获取属性代表的JDBC类型
        String jdbcType = parameterNode.getStringAttribute("jdbcType");
        // 获取resultMap属性，具体使用到的情况请看Mybatis文档 
        String resultMap = parameterNode.getStringAttribute("resultMap");
        // 获取mode属性
        String mode = parameterNode.getStringAttribute("mode");
        // 获取typeHandler属性
        String typeHandler = parameterNode.getStringAttribute("typeHandler");
        // 获取numericScale属性，该属性表示小数保留的位数
        Integer numericScale = parameterNode.getIntAttribute("numericScale");
        ParameterMode modeEnum = resolveParameterMode(mode);
        Class<?> javaTypeClass = resolveClass(javaType);
        JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);
        Class<? extends TypeHandler<?>> typeHandlerClass = resolveClass(typeHandler);
        // 将子标签构造成一个ParameterMapping
        ParameterMapping parameterMapping = builderAssistant.buildParameterMapping(parameterClass, property, javaTypeClass, jdbcTypeEnum, resultMap, modeEnum, typeHandlerClass, numericScale);
        // 并放入一个列表中
        parameterMappings.add(parameterMapping);
      }
      // 最后将结果列表注册到`Configuration`对象的`parameterMaps`属性中
      builderAssistant.addParameterMap(id, parameterClass, parameterMappings);
    }
}
```

仔细考察`builderAssistant.addParameterMap(id, parameterClass, parameterMappings);`可以发现，`Configuration`对象使用`parameterMaps`注册表存储各个`ParameterMap`，格式为`<String, ParameterMap>`。其中key是`id`，parameterMap的id是`命名空间 + id字段`，value就是parameterMap对象。

#### 解析resultMap标签

`<resultMap>`标签用于表示Mybatis数据库操作的结果集，是Mybatis引以为豪的一部分。该标签功能相当强大，在一般的结果映射上增添了许多功能。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。

解析`<resultMap>`标签的方法是`resultMapElements(List<XNode>)`，该方法只是遍历所有的`<resultMap>`标签对其进行解析罢了：

```java
private void resultMapElements(List<XNode> list) throws Exception {
    for (XNode resultMapNode : list) {
      try {
        resultMapElement(resultMapNode);
      } catch (IncompleteElementException e) {
        // ignore, it will be retried
      }
    }
  }
```

真正的解析方法其实在`resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings, Class<?> enclosingType)`中，因为`resultMapElement(resultMapNode);`就是调用的该方法，我们直接考察该方法：

```java
private ResultMap resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings, Class<?> enclosingType) throws Exception {
    ErrorContext.instance().activity("processing " + resultMapNode.getValueBasedIdentifier());
    // 获取resultMap对应的Java类型
    // 获取的顺序分别是type->ofType->resultType->javaType
    String type = resultMapNode.getStringAttribute("type",
        resultMapNode.getStringAttribute("ofType",
            resultMapNode.getStringAttribute("resultType",
                resultMapNode.getStringAttribute("javaType"))));
    // 将type属性解析为Java的Class对象
    Class<?> typeClass = resolveClass(type);
    if (typeClass == null) {
      typeClass = inheritEnclosingType(resultMapNode, enclosingType);
    }
    Discriminator discriminator = null;
    List<ResultMapping> resultMappings = new ArrayList<>();
    resultMappings.addAll(additionalResultMappings);
    List<XNode> resultChildren = resultMapNode.getChildren();
    for (XNode resultChild : resultChildren) {
      if ("constructor".equals(resultChild.getName())) {
        processConstructorElement(resultChild, typeClass, resultMappings);
      } else if ("discriminator".equals(resultChild.getName())) {
        discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);
      } else {
        List<ResultFlag> flags = new ArrayList<>();
        if ("id".equals(resultChild.getName())) {
          flags.add(ResultFlag.ID);
        }
        resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));
      }
    }
    String id = resultMapNode.getStringAttribute("id",
            resultMapNode.getValueBasedIdentifier());
    String extend = resultMapNode.getStringAttribute("extends");
    Boolean autoMapping = resultMapNode.getBooleanAttribute("autoMapping");
    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);
    try {
      return resultMapResolver.resolve();
    } catch (IncompleteElementException  e) {
      configuration.addIncompleteResultMap(resultMapResolver);
      throw e;
    }
}
```

#### 解析sqlElement标签

#### 解析语句标签
