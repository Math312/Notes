# AbstractQueuedSynchronizer

我们知道，Java中很多重要的并发组件都是基于`AQS`进行设计的，AQS本身是一个类，但是不如说他是一个框架，该框架为众多并发组件提供了底层基础。那么接下来开始分析该类。

首先考虑该类的类继承结构图：

![AbstractQueuedSynchronizer类继承结构图](./AbstractQueuedSynchronizer类继承结构图.png)

该类的类继承结构极其简单，`AbstractQueuedSynchronizer`仅仅继承了`AbstractOwnableSynchronizer`。让我们首先查看`AbstractOwnableSynchronizer`的功能以及源码。

查看`AbstractOwnableSynchronizer`代码，发现`AbstractOwnableSynchronizer`其实是一个抽象类，该类只有一个属性：

```java
private transient Thread exclusiveOwnerThread;
```

并且也只有两个方法，即`exclusiveOwnerThread`属性的getter和setter方法。

查看`AbstractOwnableSynchronizer`的注释，我们可以发现，该类是一个保存当前占用线程的同步器，考察`exclusiveOwnerThread`的属性名，我们可以知道该属性用于存储`专有的拥有者线程`，考察一般加锁流程，如果要对A对象加锁，我们会设置一个标志（此处声明为label），那么使用该对象之前，先将label更改，这里我们假设更改的命令是`label=A`，然后使用完对象将`label=null`，这里的情况同理。

`AbstractQueuedSynchronizer`也是基于`AbstractOwnableSynchronizer`完成了自己的工作，那么`AbstractQueuedSynchronizer`到底完成了什么工作呢？查看注释我们可以看到：

```java
/**
 * This class is designed to
 * be a useful basis for most kinds of synchronizers that rely on a
 * single atomic {@code int} value to represent state.
 * /
```

该类是大多数依赖单个原子性int值表示同步状态的同步器的基础。那么该类到底是怎么实现该功能的呢？注释的第一句话就有说明：

```java
/**
 * Provides a framework for implementing blocking locks and
 *  related synchronizers (semaphores, events, etc) that rely on
 *  first-in-first-out (FIFO) wait queues.
 * /
```

可以看到，该类实现上述功能依赖了FIFO的阻塞队列。但是，Java中的阻塞队列不应该是基于各种锁，同步器么？这样不就出现了循环依赖么？那么`AbstractQueuedSynchronizer`是怎么依赖的阻塞队列？因此我们考察该类的属性，查看到底使用的是什么杨的阻塞队列。该类与队列相关的属性很少，只有两个：

```java
private transient volatile Node head;
private transient volatile Node tail;
```

显而易见，这就是阻塞队列的头结点和尾节点，链表本身就用于存储数据，那该类的节点与普通链表有何不同呢？这里我们考察一下该类的Node实现：

```java
static final class Node {
    static final Node SHARED = new Node();
    static final Node EXCLUSIVE = null;
    static final int CANCELLED =  1;
    static final int SIGNAL    = -1;
    static final int CONDITION = -2;
    static final int PROPAGATE = -3;

    volatile int waitStatus;
    volatile Node prev;
    volatile Node next;
    volatile Thread thread;
    Node nextWaiter;
}
```

Node节点有4个属性，分别是：

1. waitStatus：表示当前节点包含线程的状态。该状态有5种：
   1. CANCELLED：这意味着该线程已经因为超时或者中断而取消了，这是一个终结态。
   2. SIGNAL：表示当前线程的后继线程被阻塞或者即将被阻塞，当前线程释放锁或者取消后需要唤醒后继线程，注意这个状态一般都是后继线程来设置前驱节点的。
   3. CONDITION：说明当前线程在CONDITION队列
   4. PROPAGATE：用于将唤醒后继线程传递下去，这个状态的引入是为了完善和增强共享锁的唤醒机制。在一个节点成为头节点之前，是不会跃迁为此状态的
   5. 0：表示无状态
2. prev：前驱节点
3. next：后继结点
4. thread：该节点表示的线程
5. nextWaiter：SHARED or EXCLUSIVE

默认情况下创建一个Node其waitStatus都是0状态。根据Node的注释，我们知道这条阻塞队列是一个`CLH`队列，该思想主要用于自旋锁，在接下来的代码逻辑分析中你会看到自旋锁。下面让我们查看加锁逻辑，以此观察`AQS`是如何使用上面的队列的。在`AQS`中加锁的方法有很多，例如：

1. acquire(int arg):获取互斥锁
2. acquireInterruptibly(int arg)：获取互斥锁，但是一旦被中断，则取消获取
3. acquireShared(int arg)：获取共享锁
4. acquireSharedInterruptibly(int arg)：获取共享锁，一旦被中断，则取消获取。

接下来将对前三个方法进行分析，方便了解AQS在获取互斥锁和共享锁时的区别，以及是否忽略中断的区别。

## 1. acquire(int arg)

`acquire(int arg)`方法用于获取互斥锁，并且忽略中断。考察该方法源码如下：

```java
public final void acquire(int arg) {
    // 尝试获取锁
    // 如果没有获取到，则创建一个节点放入队列中
    // 等待获取到锁，如果获取过程中，出现特殊情况，
    // 则中断当前线程，避免阻塞
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

注意`tryAquire(int)`方法负责尝试获取锁，但是需要注意，该方法在`AQS`中并没有实现，需要子类进行覆盖。因此我们需要去查看剩余的几个方法：

1. addWaiter(Node)：该方法负责创建一个Node，传入的参数表示获取锁的模式，即`Node.SHARED`或者是`Node.EXCLUSIVE`：

    ```java
    private Node addWaiter(Node mode) {
        // 创建一个Node，并通过传入参数设计其加锁模式
        // 监听的线程就是当前线程
        Node node = new Node(Thread.currentThread(), mode);
        // 获取队尾节点
        // 如果队列不为空，那么将当前节点与队尾节点连接
        // 然后执行CAS操作，将当前节点添加到pred后面zixuansuo
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        // 如果队列是空，那么就要将新节点放到队列头
        enq(node);
        return node;
    }
    ```

    接下来我们查看一下`enq(final Node)`中的细节，我们已经知道，该方法用于`处理队列是空，将头结点放到队列头`的情况，考察代码细节如下：

    ```java
    private Node enq(final Node node) {
        // 自旋+CAS 将Node添加到队列中
        for (;;) {
            Node t = tail;
            // 为了防止在调用函数过程中
            // 有别的线程把Head设置了
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
    ```

    将线程信息放入到队列中后，就要开始获取锁了，`acquireQueued`方法用于获取锁。

2. acquireQueued(final Node, int)，自旋获取锁。

    ```java
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            // 自旋+获取锁
            for (;;) {
                final Node p = node.predecessor();
                // 获取node的前一个节点，查看是否是头结点
                // 如果是头结点再进行获取锁
                // 如果获取到了，就将队列头设置为它
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                // 在没有成功获取锁的情况下判断是否应该中断获取锁
                // 判断逻辑在`shouldParkAfterFailedAcquire`方法中
                // 挂起当前线程，避免占用资源。
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            // 如果没有成功获取锁，那么要唤醒线程，并进行一系列的处理
            if (failed)
                cancelAcquire(node);
        }
    }
    ```

    这里我们考察`shouldParkAfterFailedAcquire(Node,Node)`方法来考虑加锁未成功时会发生什么？

    ```java
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            // 如果当前节点的前驱节点的状态是`SIGNAL`，
            // 这意味着前驱节点线程占用的锁释放之后，就会分配给当前节点的线程
            // 因此挂起当前线程就可以了，直接返回true，表示已经获取到锁了
            return true;
        if (ws > 0) {
            // 如果前驱节点的状态是`CANCEL`，这意味着前驱节点的任务已经被取消了，
            // 这意味着要使用第一个非`CANCEL`状态的节点与当前节点进行对比
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            // 修改指针
            pred.next = node;
        } else {
            // 到达这里证明前驱节点的状态是0或者PROPAGATE
            // 那么这时候需要前驱节点线程释放锁之后通知当前节点线程
            // 因此需要修改前驱节点线程状态为Node.SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
    ```

    如果`shouldParkAfterFailedAcquire(Node,Node)`返回true，那么意味着当前Node已经加入到阻塞队列中了，因此需要挂起当前线程，直到当前节点的前驱节点释放锁为止。因此`parkAndCheckInterrupt()`方法就是此目的：

    ```java
    private final boolean parkAndCheckInterrupt() {
        // 挂起当前线程
        LockSupport.park(this);
        // 返回是否能够中断，表示是否挂起成功
        return Thread.interrupted();
    }
    ```

    然而有些情况下，会导致执行了`parkAndCheckInterrupt()`但是却没有成功获取到锁，因此，要清除错误信息，这时就要调用`cancelAcquire(Node)`方法，代码如下：

    ```java
    private void cancelAcquire(Node node) {
        // Ignore if node doesn't exist
        if (node == null)
            return;

        node.thread = null;

        // Skip cancelled predecessors
        Node pred = node.prev;
        while (pred.waitStatus > 0)
            node.prev = pred = pred.prev;

        // predNext is the apparent node to unsplice. CASes below will
        // fail if not, in which case, we lost race vs another cancel
        // or signal, so no further action is necessary.
        Node predNext = pred.next;

        // Can use unconditional write instead of CAS here.
        // After this atomic step, other Nodes can skip past us.
        // Before, we are free of interference from other threads.
        node.waitStatus = Node.CANCELLED;

        // If we are the tail, remove ourselves.
        if (node == tail && compareAndSetTail(node, pred)) {
            compareAndSetNext(pred, predNext, null);
        } else {
            // If successor needs signal, try to set pred's next-link
            // so it will get one. Otherwise wake it up to propagate.
            int ws;
            if (pred != head &&
                ((ws = pred.waitStatus) == Node.SIGNAL ||
                 (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&
                pred.thread != null) {
                Node next = node.next;
                if (next != null && next.waitStatus <= 0)
                    compareAndSetNext(pred, predNext, next);
            } else {
                unparkSuccessor(node);
            }

            node.next = node; // help GC
        }
    }
    ```

3. selfInterrupt()：中断当前线程

    该方法负责中断线程：

    ```java
    static void selfInterrupt() {
        Thread.currentThread().interrupt();
    }
    ```

## 2. acquireInterruptibly(int)

该方法与`aquire(int)`方法的区别是，当线程中断时，会将加锁逻辑中断，而`aquire(int)`则不会。`acquireInterruptibly(int)`在实现上与`aquire(int)`有两处不同：

1. 在真正进行`tryAcquire(int)`之前进行了中断检测：

    ```java
    public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }
    ```

2. 当在加锁过程中遇到中断时不再是设置标志值，而是抛出异常：

    ```java
    if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
        throw new InterruptedException();
    ```

## 3. acquireShared(arg)

该方法与`acquire(int arg)`的区别是`acquireShared(arg)`的加锁模式是共享锁，而`acquire(int arg)`的加锁模式是异步锁。