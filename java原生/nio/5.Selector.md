# Selector

最后我们介绍NIO中相当重要的Selector，在文章最初我们介绍了IO多路复用，但是在之前都没有提到，这里我们开始提到它，但是在真正提到IO多路复用时，我们还是要先看一下Java的接口，以及一些其他相关信息。

Selector，顾名思义就是选择器，我们之前提到的IO多路复用无非也就是一种选择，选择器不断选择出可用的fd交给业务系统处理。这些选择器都是由操作系统支持提供的，因此，Java的选择器实例都是由`SelectorProvider`进行提供的，默认情况下，SunOS系统使用的是`DevPollSelectorProvider`，Linux系统使用的是`EPollSelectorProvider`，其余系统使用的是`PollSelectorProvider`。

由于笔者使用的是Linux，因此这里我们这里使用`EPollSelectorProvider`作为例子进行分析。在分析之前，我们需要有一些EPoll的基础知识，详情请查看[这里](./../../Linux/多路复用/1.Epoll.md)

从 `SelectorProvider`开始吧，毕竟他是Selector的起点。

## 1. SelectorProvider

查看SelectorProvider的注释，我们发现，SelectorProvider不仅仅提供Selector，也提供SelectableChannel。Selector是选择器，用于提供多路复用的相关功能，那么什么是SelectorProvider呢？

我们知道多路复用功能并不是对所有的fd都适用的，例如文件IO的fd就不适用于多路复用功能，对于linux来说，这类fd没有实现poll()方法，但是Java没有这个方法，因此，这类fd就不是SelectableChannel。

`SelectorProvider`提供了如下几种`SelectableChannel`：

1. DatagramChannel
2. ServerSocketChannel
3. SocketChannel

这里我们首先考虑`SelectorProvider`的基本任务，提供`SelectorProvider`，这里考察其`provider()`方法：

```java
public static SelectorProvider provider() {
    synchronized (lock) {
        if (provider != null)
            return provider;
        return AccessController.doPrivileged(
            new PrivilegedAction<SelectorProvider>() {
                public SelectorProvider run() {
                    if (loadProviderFromProperty())
                        return provider;
                        if (loadProviderAsService())
                            return provider;
                        provider = sun.nio.ch.DefaultSelectorProvider.create();
                        return provider;
                    }
                });
    }
}
```

可以看到，`SelectorProvider`通过provider属性保存已经获取到的`SelectorProvider`，如果已经有存储了就直接返回，否则根据如下三个步骤进行创建：

1. 从配置属性进行加载，即加载`System.getProperty("java.nio.channels.spi.SelectorProvider");`指定的类
2. 通过ServiceLoader进行加载
3. 使用系统默认的SelectorProvider

获取到真正的`SelectorProvider`就可以创建`Selector`了，实际上`SelectorProvider`创建`Selector`的`openSelector()`方法只是简单的使用构造器创建：

```java
public AbstractSelector openSelector() throws IOException {
    return new EPollSelectorImpl(this);
}

public AbstractSelector openSelector() throws IOException {
    return new PollSelectorImpl(this);
}
```

并且此时我们考虑`SelectorProvider`提供`SelectableChannel`的方法也和`openSelector()`类似，是直接用构造器创建一个`SelectableChannel`。

```java
public ServerSocketChannel openServerSocketChannel() throws IOException {
    return new ServerSocketChannelImpl(this);
}

public SocketChannel openSocketChannel() throws IOException {
    return new SocketChannelImpl(this);
}

public DatagramChannel openDatagramChannel() throws IOException {
    return new DatagramChannelImpl(this);
}

public DatagramChannel openDatagramChannel(ProtocolFamily family) throws IOException {
    return new DatagramChannelImpl(this, family);
}
```

## 2.Selector

了解了Selector的来源，现在我们开始具体查看Selector是什么样子的。

`Selector`是一个抽象类，定义了Selector的基本方法。

首先是创建方法，即`open()`方法：

```java
public static Selector open() throws IOException {
    return SelectorProvider.provider().openSelector();
}
```

该方法已经不陌生了，调用SelectorProvider的openSelector()方法获取Selector。可以通过`isOpen()`方法查看`Selector`的开启状态。也可以通过`provider()`方法获取创建该`Selector`的`SelectorProvider`。