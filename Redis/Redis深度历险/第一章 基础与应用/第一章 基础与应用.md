## 第一章 基础与应用

### 1.1 Redis可以做什么

1. 记录帖子的点赞数、评论数、点击数（Hash）
2. 记录用户帖子ID列表（排序），便于快速显示用户的帖子列表（zset）
3. 记录帖子的标题、摘要、作者和封面信息，用于列表页的展示（Hash）
4. 记录帖子的点赞用户ID列表、评论ID列表，用于显示和去重计数（zset）
5. 缓存近期热帖内容（帖子内容的空间占用比较大），减少数据库压力（Hash）
6. 记录帖子的相关文章ID，根据内容推荐相关帖子（list）
7. 如果帖子ID是整数自增的，可以使用Redis来分配帖子ID（计数器）
8. 收藏集和帖子之间的关系（zset）
9. 记录热榜帖子ID列表、总热榜和分类热榜（zset）
10. 缓存用户行为历史，过滤恶意行为（zset、hash）

### 1.2 Redis的基础数据结构

Redis五种基本数据结构，分别为string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。

1. string（字符串）

	Redis字符串内部结构是一个字符数组，是一个动态字符串，可以修改的字符串，内部结构实现类似于Java的ArrayList，采用与分配冗余空间的方式来减少内存的频繁分配，内部为当前字符串分配的实际空间capacity一般要高于实际字符串长度len。当字符串长度小于1MB，扩容都是加倍现有的空间。如果字符串长度超过1MB，扩容时一次只会多扩1MB的空间。需要注意的是字符串最大长度为512MB。

	![Redis字符串结构](./images/white.png)

	常见命令：

	命令|作用|事例|返回结果
	---|---|---|---
	set|添加key-value|set name codehole|是否添加成功
	get|根据key获取value|get name|key为name的value值
	mget|读取多个key的value|mget name1 name2 name3|三个key的值的列表
	mset|设置多个key-value值|mset name1 boy name2 value2 |设置结果
	expire|为key设置超时时间|expire name 5|设置结果（将key为name的键值对的超时时间设置为5s）
	setnx|添加键值对并同时设置超时时间|setnx name 5 codehole|设置简直对name-codehole并将其超时时间设置为5s
	incr|如果字符串是数值则自增1|incr age|age+1
	decr|如果字符串是数值则自减1|decr age|age-1
	incrby|如果字符串是数值则自增指定数值|incrby age 3|age+3
	decrby|如果字符串是数值则自减指定数值|decrby age 3|age-3

	字符串由多个字节组成，每个字节又由8个bit组成，如果可以将一个字符堪称很多个bit的组合，即位图。

2. list（列表）

	Redis的列表相当于Java的LinkedList，它是链表不是数组。这意味着list的插入和删除操作非常快，时间复杂度为O(1)，但是索引定位很慢，时间复杂度为O(n)，列表中的每个元素都使用双向指针顺序，串起来可以同时支持前向后向遍历。当列表被弹出了最后一个元素之后，该数据结构被自动删除，内存被回收。

		 ---     ---     ---     ---     ---
		|   |<->|   |<->|   |<->|   |<->|   |
		 ---     ---     ---     ---     ---

	Redis的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化为字符串，塞进Redis队列，另一个线程从这个列表中轮询数据进行处理。
	常见命令：
	命令|作用|事例|返回结果
	---|---|---|---
	rpush|从右压入数据|rpush books python java golang|队列中数据的长度
	llen|列表长度|llen books|列表长度
	lpop|从左弹出数据|lpop books|python（最左元素）
	rpop|从右弹出数据|rpop books|golang（最右元素)
	lpush|从最左压入数据|lpush books python java golang| 队列的长度
	lindex|获取指定索引的值|lindex books 1|返回books中索引值为1处的value
	ltrim|保留指定区间内的值，其余的统统删除|ltrim start_index end_index|保留start_index 到end_index之间的所有数据

	Redis列表的底层存储结构不是一个简单的linkedList，而是一种称之为快速列表的结构。首先在列表元素较少的情况下，会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。它将所有的元素彼此紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会浪费空间，还会加重内存的碎片化。所以Redis将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist使用双向指针连接起来，既满足了快速的插入删除性能，又不会出现太大的空间冗余。

		 -------     -------     -------     -------     -------
		|ziplist|<->|ziplist|<->|ziplist|<->|ziplist|<->|ziplist|
		 -------     -------     -------     -------     -------

3. hash（字典）

	Redis的字典相当于Java语言里的HashMap，它是无序字典，内部存储了许多键值对，结构上和Java的HashMap是一样的，都是数组+链表的结构。

			  --- key --- value
			 |
		hash- --- key --- value
		     |
			  --- key --- value

	与HashMap不同的是Redis的字典的值只能是字符串，并且它们的rehash方式不同。HashMap的rehash是一次性的完全rehash，Redis为了追求高性能，不能阻塞服务，采用了渐进式rehash策略。
	渐进式rehash会在rehash的同时，保留新旧两个hash结构，如下图

		 ----- -----                        ----- -----
		|ht[0]|ht[1]|                      |ht[0]|ht[1]|
		 ----- -----                        ----- -----
		   |                                  |     |
		   |             ---->      old    --       --     new  
		   *                               *           *
		 ---------                  ---------        ---------
		|hashtable|                |hashtable|      |hashtable|
		 ---------                  ---------        ---------

	查询时会同时查询两个hash结构，然后在后续的定时任务以及hash操作指令中，循序渐进地将旧hash内容一点点地迁移到新的hash结构中。当搬迁完成后，就会使用心得hash结构取而代之。

	当hash结构移除了最后一个元素后，该数据结构会被自动删除，内存被回收。hash结构也可以用来存储信息，而且相比于字符串来说，hash结构可以对单个字段进行存储，如果需要查找单个字段可以减少网络流量对开销。但是hash结构的存储消耗要高于单个字符串。

	常用命令：
	命令|介绍|事例|返回结果
	---|---|---|---

4. set（集合）

	Redis集合相当于Java里面的HashSet，它内部的键值对是无序的、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值NULL。
	当集合中最后一个元素被移除之后，数据结构被自动删除，内存被回收。
	
	常用命令：
	命令|介绍|事例|返回结果
	---|---|---|---

5. zset（有序列表）
