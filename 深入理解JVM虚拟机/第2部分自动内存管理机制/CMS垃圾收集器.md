# CMS垃圾收集器

CMS垃圾收集器是一个老年代处理器，与其能良好配合的新生代垃圾收集器有Serial和Parnew。不过自JDK9开始，官方取消了Serial和CMS的搭配，其实原本就很少使用，甚至直接取消了`-XX:+UseParNewGC`参数，从此ParNew只能和CMS搭配使用。

接下来主要介绍CMS，CMS的全称是（Concurrent Mark Sweep），即并发标记清除算法。因此，与一般的老年代垃圾收集器不同，CMS使用的是标记清除算法。

我们知道传统的垃圾收集算法有3中：标记-清除算法、复制算法、标记-整理算法。而老年代垃圾收集器一般使用的都是标记-整理算法，例如Serial Old和Parallel Old，那么为何CMS会选择使用标记清除算法呢？这还要说到CMS的目标。CMS是一种以获取最短停顿时间为目标的垃圾收集器。我们知道老年代中的对象很多都是常驻对象，因此，GC并没有那么频繁，复制算法和标记-整理算法都有移动对象在内存空间中位置的操作，这样会导致垃圾收集时间肯定要比标记-清除算法要长。而且更重要的是在老年代对象移动和用户线程是很难并发执行的，只能发生Stop The World。因此，采用标记-清除算法是最好的选择。

## CMS的执行流程

CMS将GC分为4步：

1. 初始标记：标记GC Roots能直接关联到的对象
2. 并发标记：从GC Roots能直接关联到的对象并发遍历整个对象图
3. 重新标记：修正并发标记期间，因用户程序继续运作导致标记产生变动的记录
4. 并发清除：清理删除标记阶段判断已经死亡的对象。

上述4部中仅仅初始标记和重新标记需要STW，其余的步骤都可以与用户线程并发执行。而初始标记与重新标记所耗费的时间也很短。因此达到了CMS最短停顿时间的目的。

但是由于CMS的并发标记与并发清除是与用户线程并发执行的，因此在并发收集垃圾时要为用户线程剩下足够的内存，以保证用户线程能够正常运行。CMS默认情况下为用户进程留下32%的内存空间，CMS提供了一个参数`-XX:CMSInitiaiongOccu-pancyFraction`用于动态更改此配置，注意，此参数设置的是当内存到达何值时会进行清理。当CMS无法为用户线程提供如此多闲置内存，即到达了`-XX:CMSInitiaiongOccu-pancyFraction`配置的上限时，就会出现`Concurrent Mode Failure`的情况，此时，CMS将会STW，然后进行一次Full GC，这就是之前说的CMS使用Serial Old的情况。需要注意，并不是`-XX:CMSInitiaiongOccu-pancyFraction`设置的越高越好，因为老年代的对象很少是需要被清除的，因此，尽管进行了Full GC，也清除不了太多内存，因此如果`-XX:CMSInitiaiongOccu-pancyFraction`设置的太高，会导致频繁出现到达`-XX:CMSInitiaiongOccu-pancyFraction`参数设置的峰值的情况，频繁进行Full GC。

上面说的两种情况中，进行清除无用对象时使用的都是标志清除算法，我们都知道这种方法会产生大量的内存碎片，导致当创建大对象时，很有可能无法为其分配空间，这时就算使用标志-清理算法进行Full GC也是没有任何用处的。为了处理这个问题，CMS在不得不进行Full GC合并内存碎片时，就移动存活对象。而为了不让这种情况频繁出现，Java提供了`-XX:CMSFullGCsBefore-Compaction`参数，用于保证每进行n次标志-清理的Full GC，就进行一次标志整理的Full GC。

## CMS的缺点

CMS的缺点相对明显：

1. 由于CMS是使用并发方式处理问题，因此对处理器资源相当敏感，尽管所有的并发程序都对服务器资源敏感。默认情况下CMS启动的回收线程数是（处理器核心数量+3）/4.因此如果核心数量低于4个，那么用户进程的效率就会大大降低。
2. 当CMS在老年代垃圾很多的时候可能出现频繁进行Full GC的现象。

## CMS的优点

STW相对较小，当然Full GC频繁时除外。
