## 第8章 虚拟机字节码执行引擎

### 8.1 概述

执行引擎是Java虚拟机最核心的组成部分之一，虚拟机的执行引擎是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。

Java执行代码时可能会有==解释执行==和==编译执==行两种选择，但是，==输入的都是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果==。

### 8.2 运行时栈帧结构

栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了==方法的局部变量表、操作数栈、动态连接和方法返回地址==等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

在编译代码时，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中。

对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。之心的所有字节码指令都只针对当前栈帧进行操作。

#### 8.2.1 局部变量表

局部变量表是一组变量值存储空间，用于==存放方法参数和方法内部定义的局部变量==。在Java程序编译为Class文件时，就在==方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量==。

==局部变量表的容量以变量槽（Slot）为最小单位，每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据==。并且Slot的长度可以随着处理器、操作系统或虚拟机的不同而发生变化。

reference表示对一个对象实例的引用，虚拟机规范没有规定reference的长度，但至少能做到如下两点：
1. 从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引。
2. 此引用中直接或间接地查找到对象所属数据类型在方法区中存储的类型信息。

==对于64位的数据类型，虚拟机会以高位对其的方式为其分配两个连续的Slot空间==。虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，索引n就代表了使用第n个Slot，如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot。

==为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的==。方法体中定义的变量，其作用域并不一定会覆盖整个方法体，==如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用==。

局部变量表Slot的重用是需要等到下一次局部变量表的读写操作的，并非是超出作用域就进行空间清理。不使用的对象设置为null，也正是因为这个原因。

除此之外，局部变量表不存在准备阶段，即类加载中的第一次初始化，因此，在Java语法中，局部变量不会被赋予默认值。

#### 8.2.2 操作数栈

操作数栈也称为操作栈，它是一个后入先出的栈。同局部变量表一样，==操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中==。==操作数栈的每一个元素可以是任意的Java数据类型，包括long和double==。==32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。方法执行的任何时候操作数栈的深度都不会超过max_stacks数据项中设定的最大值==。

在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在==大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠==。让下面的栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，达到==公用数据==的目的。

Java虚拟机解释执行引擎称为“基于栈的执行引擎”。

#### 8.2.3 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，为了支持方法调用过程中的动态连接。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。
#### 8.2.4 方法返回地址

当一个方法开始执行后，有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回字节码指令，这时候可能会有返回值传递给上层的方法调用者，称为正常完成出口。另一种退出方式是方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，这种退出方式称为异常完成出口。

方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。

方法退出时实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值亚茹调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。

#### 8.2.5 附加信息

虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述信息到栈帧之中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。

### 8.3 方法调用

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，暂时不涉及方法内部的具体运行过程。

#### 8.3.1 解析

调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。在Java中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类。

Java虚拟机里提供了5条方法调用字节码指令：
1. invokestatic:调用静态方法
2. invokespecial：调用实例构造器<init>方法、私有方法和父类方法
3. invokevirtual：调用所有的虚方法
4. invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象
5. invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在之前的4条调用命令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类。它们在类加载的时候就会把符号引用解析为该方法的直接引用。这类方法称为非虚方法，与之相反，其他方法称为虚方法（除去final方法，后文会提到）。

被final修饰的方法虽然使用invokevirtual调用，但是它没有其他版本。Java语言规范中明确说明了final方法是一种虚方法。

#### 8.3.2 分派调用

##### 1.静态分派

    Human man = new Man();
    
上述代码中，Human称为变量的静态类型，或者叫做外观类型，后面的Man称为变量的实际类型，静态类型和实际类型再程序中都可能发生一些变化，静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的。实际类型变化的结果在运行期才可以确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。

编译器虽然能确定出方法的重载版本，但是在很多情况下这个重载版本并不是唯一的，往往只能确定一个“更加合适的”版本。

除此之外，解析和分派这两者之间的关系并不是二选一的排他关系，例如静态方法在类加载时就进行解析，但是静态方法也可以进行重载，那么选择重载版本的过程也是通过静态分派完成的。

#####  2.动态分派

invokevirtual指令的运行时解析过程大致分为如下步骤：

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。
2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。
3. 否则，按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程。
4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

invokevirtual指令的第一步就是在运行期确定接收者的实际类型。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

##### 3.单分派和多分派

方法的接收者和方法的参数统称为方法的宗量。根据方法宗量的多少，可以将分派划分为单分派和多分派。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。

Java是个静态多分派，动态单分派的语言。

##### 4.虚拟机动态分派的实现

最常用的“稳定优化”手段就是为类在方法区中建立一个虚方法表，与之对应的，在invokeinterface执行时也会用到接口方法表——Inteface Method Table，使用虚方法表索引来代替元数据查找提高性能。

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有重新，那子类的虚方法表里面的入口和弗雷形同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。

为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。

方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。

除了该种稳定优化手段外，在条件允许的情况下，还会使用内敛缓存和基于“类型继承关系分析”技术的守护内联。

#### 8.3.3 动态类型语言支持

### 8.4 基于栈的字节码解释执行引擎

