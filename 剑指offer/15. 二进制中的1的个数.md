# 15. 二进制中1的个数

## 题目

题目一：请实现一个函数，输入一个整数，输出该数二进制标志中1的个数。

## 思路：

题目一：

输入整数为num

1. 设置变量rs存储结果，并初始化为0，当num不为0时，无限循环，循环内，当num&1 == 1时证明该位是1，那么就对rs++，然后num无符号右移一个单位，循环结束返回结果。
2. 采用把num-1后的变量与num进行按位与的操作，这样操作的结果会把num最右边的1全变为0，那么有多少位1，就可以执行多少次这样的操作，直到num为0为止。

PS:这里解释一下，考察二进制数减一的效果：1. 如果该二进制数最右面是1，那么最右面的1变为0，其余位不变。这时，如果和原数字按位与，会将最右面的1变为0。2如果该二进制数最右面为0，我们假设该数字最右面有n个连续的0，那么造成的结果是从右面数的前n位都会变为1，第n+1位会变为与原数字n+1位相反的字符，这时进行按位与，也会达到上述效果。


## 代码

思路1：

    public int solution(int data){
        int rs = 0;
        while(data != 0){
            if(((int)data & 1) == 1)
                rs ++;
            data = data >>> 1;
        }
        return rs;
    }

PS:需要注意这里使用的是`>>>`，而不是`>>`，如果使用`>>`，在输入负数时会产生无限循环，如果某些语言不支持`>>`，我们可以反向考虑这个问题，不对data&1进行判断，而是通过对一个初始值为1的变量不断左移，再与data进行与操作，如果不为0，那么就让计数器加1，否则进行下一次循环，当这个变量中的1被左移没了为止，当然这个判断条件可能会导致一些资源的浪费，代码如下：

    public int solution(int data){
        int rs = 0;
        int flag = 1;
        while(flag != 0){
            if(((int)data & flag) != 0)
                rs ++;
            flag <<= 1;
        }
        return rs;
    }

思路2：

    public int solution(int data){
        int rs = 0;
        while(data){
            ++ rs;
            data = (data-1)&data;
        }
        return rs;
    }

