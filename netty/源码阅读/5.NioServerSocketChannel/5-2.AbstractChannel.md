# 5-2 AbstractChannel

该类是Channel接口的模板方法实现。该类完成的主要功能如下：

1. 具体的业务操作委托给`ChannelPipeline`
2. 网络操作委托给`Unsafe`接口。
3. 提供统一异步返回结果接口（`ChannelFuture`和`ChannelPromise`）
4. 将`Channel`和`EventLoop`整合在一起

为了完成上述三个功能，`AbstractChannel`声明了如下属性：

```java
    // 网络操作委托给Unsafe接口
    private final Unsafe unsafe;
    // 业务操作委托给`ChannelPipiline`
    private final DefaultChannelPipeline pipeline;
    // 提供统一异步返回接口
    private final ChannelFuture succeededFuture = new SucceededChannelFuture(this, null);
    private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);
    private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);
    private final CloseFuture closeFuture = new CloseFuture(this);
    // 将Channel和EventLoop整合在一起
    private volatile PausableChannelEventLoop eventLoop;
```

对于Netty来说，Channel只能通过EventLoop进行处理，在这里就将EventLoop和Channel耦合起来了。

之前我们将Channel接口声明的方法分为了3类：

1. 查询类方法
   1. 查询Channel的配置信息：Channel实现自身处理
   2. 查询Channel的状态信息：Unsafe实现处理
2. 操作类方法
    1. 网络操作相关的方法：ChannelPipeline处理
    2. 通用操作相关的方法：Channel实现自身处理
3. 结果类方法：Channe实现自身处理

接下来我们会按照方法的类别开始对`AbstractChannel`进行分析。

## 1. 构造器

`Channel`接口中定义了`Channel`的一个特性：

```
Channels are hierarchical.
```

Channel具有父级Channel这个概念，如果A Channel创建了B Channel，那么A就是B的父级Channel。

除此之外，Channel中必不可缺的属性就是一个ID，每个Channel要通过这个ID进行区分。

满足了这些条件之后，就可以创建一个`AbstractChannel`了。

```java
    protected AbstractChannel(Channel parent) {
        this.parent = parent;
        id = DefaultChannelId.newInstance();
        unsafe = newUnsafe();
        pipeline = new DefaultChannelPipeline(this);
    }

    protected AbstractChannel(Channel parent, ChannelId id) {
        this.parent = parent;
        this.id = id;
        unsafe = newUnsafe();
        pipeline = new DefaultChannelPipeline(this);
    }

```

默认情况下`AbstractChannel`使用的pipeline是`DefaultChannelPipeline`，而unsafe是通过`newUnsafe()`方法获取的。该方法由子类覆盖，方便子类提供自己的`Unsafe`实现。

## 2. 查询类方法

Channel作为服务端与客户端交互的通道，需要监控其配置与状态，Channel接口要求实现一系列这种查询状态和配置信息的方法。接下来我们详细讨论这两部分方法的实现。

### 2.1 配置信息查询方法

我们知道，对于传输层协议来说，例如TCP，在建立连接时会有很多配置信息。服务端与客户端通过配置信息建立连接。除此之外，我们已经看到了，Channel自身需要4个资源：

1. id
2. parent
3. eventloop
4. pipeline

这部分方法都由`AbstractChannel`自身维护，例如：

```java
public final ChannelId id() {return id;}
```

刚才提到的不是上面4个属性的配置信息存储在一个特定的位置里面。`AbstractChannel`并没有规定这个表的类型。但是，该部分信息由如下方法获取：

```java
ChannelMetadata metadata();
ChannelConfig config();
```

毕竟对于不同的`Channel`，他们的`metadata`格式并不相同，但是对于`Channel`来说，他们又有相同的配置属性`ChannelConfig`。

### 2.2 查询状态信息的方法

与刚才的配置信息不同，这部分方法是用于监控`Channel`的状态的，例如该`Channel`是否是活跃的，是否被注册到对应的EventLoop中，等等。

这部分方法通常都由一系列布尔类型的属性或者通过`Unsafe`接口获取，典型的例如：

```java
    private volatile SocketAddress localAddress;
    public SocketAddress localAddress() {
        SocketAddress localAddress = this.localAddress;
        if (localAddress == null) {
            try {
                this.localAddress = localAddress = unsafe().localAddress();
            } catch (Throwable t) {
                return null;
            }
        }
        return localAddress;
    }

    public boolean isWritable() {
        ChannelOutboundBuffer buf = unsafe.outboundBuffer();
        return buf != null && buf.isWritable();
    }
```

另外再举一个使用Bool类型保存状态的例子：

```java
    private volatile boolean registered;
    @Override
    public boolean isRegistered() {
        return registered;
    }
```

通过上面的方法，Channel的配置、状态就可以通过这些接口清晰的展示。但这些的最终目的都是进行一系列业务操作，接下来让我们介绍这些业务接口。

## 3. 操作类方法

对于Channel来说，它的功能就是建立客户端与服务端的通道，并处理两端的信息流交互。然而网络交互其实流程都很相似，发送数据时，把一个数据块推到网络中，接收数据时，把网络中的数据读到数据块中。

所以Channel提供了两类方法：

1. 进行网络IO处理的方法
2. 数据读取时通用的方法

### 3.1 网络操作相关的方法

虽然在功能说明上，`Channel`是用于进行网络交互操作的，但是实际上，网络操作实际上都是由`ChannelPipeline`处理的。例如Channel绑定端口的操作：

```java
public ChannelFuture bind(SocketAddress localAddress) {
    return pipeline.bind(localAddress);
}
```

有一些方法的实现可能除了需要`ChannelPipeline`配合，可能还需要`EventLoop`配合，例如`deregister()`方法：

```java
    public ChannelFuture deregister() {
        eventLoop.rejectNewTasks();
        return pipeline.deregister();
    }
```

### 3.2 数据读取通用方法

事实上，这部分方法通常是Buffer的创建方式，`AbstractChannel`其实并没有规定具体的分配方式，但是却给了一个获取Buffer分配器的获取方式，即如下方法：

```java
    public ByteBufAllocator alloc() {
        return config().getAllocator();
    }
```

其实这个方法还是一个查询配置类的方法。

### 4. 结果类方法

上面的方法初始化并使用Channel处理网络请求，但是没有返回状态，而且由于Channel的所有操作都是异步的，因此需要一套异步操作结果处理机制。所以Netty提供了各种ChannelFuture和ChannelPromise。并且这部分方法由`Channel`的实现类进行处理。例如：

```java
public ChannelProgressivePromise newProgressivePromise() {
    return new DefaultChannelProgressivePromise(this);
}
```

## 4. AbstractUnsafe类

既然在上面，我们已经把接口中的方法分为了3类，并都交给了特定的对象进行存储，那么要`Unsafe`接口做什么呢？上面具体使用`Unsafe`接口的方法只有查询类查询Channel状态的方法啊，但是`Unsafe`接口中的方法有很多都是网络操作。

举个例子，通过EventLoop源码的分析，我们都知道`Channel`需要注册到`EventLoop`中才能使用，然而`Channel`接口并没有提供`register(EventLoop)`方法，然而真正注册时是按照如下方法进行注册的：

```java
channel.unsafe().register(this, promise);
```

除此之外，我们刚才看到`AbstractChannel`将网络操作相关的方法全部委托给了`ChannelPipeline`，我们这里以`bind(...)`方法举例，在`AbstractChannel`中，该方法是这么实现的：

```java
    public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
        return pipeline.bind(localAddress, promise);
    }
```

而且我们知道，这里的`pipeline`默认是`DefaultChannelPipeline`类型，那么我们再看`DefaultChannelPipeline`中的`bind(...)`实现：

```java
    public void bind(
                ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)
                throws Exception {
        unsafe.bind(localAddress, promise);
    }
```

事实证明Unsafe方法为我们完成了具体的业务实现，可以理解为`Channel`是抽象层，而`Unsafe`是实现层。那么如果想要了解具体业务怎么实现的，就需要看`Unsafe`接口的具体实现了。接下来让我们解析一下`AbstractUnsafe`这个类。

由于网络中的数据需要通过Buffer才能到达应用进行处理，而Buffer的无需过度定制化，因此`AbstractUnsafe`提供了如下属性：

```java
private ChannelOutboundBuffer outboundBuffer = new ChannelOutboundBuffer(AbstractChannel.this);
private RecvByteBufAllocator.Handle recvHandle;
```

上面的属性仅仅提供了应用写出数据到网络中使用的缓存，即`outboundBuffer`属性提供的缓存。网络读入到应用程序的缓存并没有给出，而是交给`recvHandle`进行动态分配。而获取`recvHandle`的方式就是如下方法：

```java
        public RecvByteBufAllocator.Handle recvBufAllocHandle() {
            if (recvHandle == null) {
                recvHandle = config().getRecvByteBufAllocator().newHandle();
            }
            return recvHandle;
        }
```

这里顺便给出获取`outboundBuffer`的方法：

```java
public final ChannelOutboundBuffer outboundBuffer() {return outboundBuffer;}
```

需要注意`AbstractUnsafe`仅仅对某些特定的方法进行了具体的实现，对于大多数方法仍然是模板方法。接下来我们只对几个`Channel`网络操作常用的方法进行分析。

1. bind(final SocketAddress localAddress, final ChannelPromise promise)

    使用Channel进行服务端开发时，首先需要将其绑定到特定的端口上，该方法主要负责此功能。

    ```java
    public final void bind(final SocketAddress localAddress, final ChannelPromise promise) {
            // 可行性校验
            ...
            // 判断当前Channel是否是活跃的
            boolean wasActive = isActive();
            try {
                // 尝试绑定到对应的地址
                // 子类实现
                doBind(localAddress);
            } catch (Throwable t) {
                // 如果失败了则返回异步通知
                safeSetFailure(promise, t);
                closeIfClosed();
                return;
            }
            // 如果成功绑定并且变为活跃的，那么异步执行pipeline的fireChannelActive方法
            if (!wasActive && isActive()) {
                invokeLater(new OneTimeTask() {
                    @Override
                    public void run() {
                        pipeline.fireChannelActive();
                    }
                });
            }
            // 异步通知成功绑定
            safeSetSuccess(promise);
        }
    ```

    可以看到，该方法是一个模板方法，该模板方法只是格式化了绑定成功或者失败时的结果返回。在Channel首次激活时异步调用`pipeline.fireChannelActive();`。真正的绑定逻辑在`AbstractChannel.doBind()`方法中，该方法是一个`abstract方法`。

    ```java
    protected abstract void doBind(SocketAddress localAddress) throws Exception;
    ```

2. register(EventLoop eventLoop, final ChannelPromise promise)

    只有把Channel注册到EventLoop中，EventLoop才能监听这个Channel，该方法主要负责该功能。

    ```java
    public final void register(EventLoop eventLoop, final ChannelPromise promise) {
            // 参数校验，校验失败后设置promise
            ...

            // 将eventLoop包装成PausableChannelEventLoop
            if (AbstractChannel.this.eventLoop == null) {
                AbstractChannel.this.eventLoop = new PausableChannelEventLoop(eventLoop);
            } else {
                AbstractChannel.this.eventLoop.unwrapped = eventLoop;
            }
            // 如果eventLoop内的注册就直接注册，否则交给eventLoop处理
            if (eventLoop.inEventLoop()) {
                register0(promise);
            } else {
                try {
                    eventLoop.execute(new OneTimeTask() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                } catch (Throwable t) {
                    logger.warn(
                            "Force-closing a channel whose registration task was not accepted by an event loop: {}",
                            AbstractChannel.this, t);
                    closeForcibly();
                    closeFuture.setClosed();
                    safeSetFailure(promise, t);
                }
            }
        }

    private void register0(ChannelPromise promise) {
            try {
                // 参数校验
                ...
                // 判断是否是第一次注册
                boolean firstRegistration = neverRegistered;
                // 注册
                doRegister();
                neverRegistered = false;
                registered = true;
                // 标识eventLoop开始接收任务
                eventLoop.acceptNewTasks();
                // 设置成功注册结果
                safeSetSuccess(promise);
                // 触发pipeline.fireChannelRegistered();
                pipeline.fireChannelRegistered();
                // 如果第一次注册，那么触发pipeline.fireChannelActive();
                if (firstRegistration && isActive()) {
                    pipeline.fireChannelActive();
                }
            } catch (Throwable t) {
                // 关闭fd，避免fd泄露
                closeForcibly();
                closeFuture.setClosed();
                safeSetFailure(promise, t);
            }
        }
    ```

    同样，该方法是一个模板方法，完成的功能同样还是触发`pipline`对应事件，以及修改异步处理结果。`AbstractChannel.doRegister()`同样是要求子类具体实现：

    ```java
    protected void doRegister() throws Exception {
        // NOOP
    }
    ```

3. beginRead()

    当一个请求到达服务端时，服务端需要将网络中的数据读取到buffer中，然后在对其进行处理

    ```java
    public final void beginRead() {
            if (!isActive()) {
                return;
            }

            try {
                doBeginRead();
            } catch (final Exception e) {
                invokeLater(new OneTimeTask() {
                    @Override
                    public void run() {
                        pipeline.fireExceptionCaught(e);
                    }
                });
                close(voidPromise());
            }
        }
    ```

    ```java
    protected abstract void doBeginRead() throws Exception;
    ```

4. write(Object msg, ChannelPromise promise)

    当一个请求到达服务端时，服务端对其进行一系列的业务操作，然后返回响应结果，该方法就负责将响应结果推到缓冲区。然后再由`flush()`方法将缓冲区的数据刷到网络中。

    ```java
    public final void write(Object msg, ChannelPromise promise) {
            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            // 业务校验
            ...
            int size;
            try {
                // 过滤响应数据
                // 子类实现
                msg = filterOutboundMessage(msg);
                // 获取响应字节数
                size = estimatorHandle().size(msg);
                if (size < 0) {
                    size = 0;
                }
            } catch (Throwable t) {
                safeSetFailure(promise, t);
                ReferenceCountUtil.release(msg);
                return;
            }
            // 将相应数据放入到缓存中
            outboundBuffer.addMessage(msg, size, promise);
        }
    ```

    同样是模板方法，不过这次没有触发`pipeline`的操作。不过提供了过滤相应数据的方法`AbstractChannel.filterOutboundMessage(Object msg)`

5. flush()

    写入到缓冲区的数据只有被flush到网络中才是发送出去了，该方法用于将缓冲区的数据刷到网络中。

    ```java
        public final void flush() {
            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            if (outboundBuffer == null) {
                return;
            }
            // 标识buffer要被flush
            outboundBuffer.addFlush();
            flush0();
        }

        protected void flush0() {
            if (inFlush0) {
                // Avoid re-entrance
                return;
            }
            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            if (outboundBuffer == null || outboundBuffer.isEmpty()) {
                return;
            }
            inFlush0 = true;
            if (!isActive()) {
                try {
                    if (isOpen()) {
                        outboundBuffer.failFlushed(NOT_YET_CONNECTED_EXCEPTION);
                    } else {
                        outboundBuffer.failFlushed(CLOSED_CHANNEL_EXCEPTION);
                    }
                } finally {
                    inFlush0 = false;
                }
                return;
            }

            try {
                // 刷出数据到网络
                doWrite(outboundBuffer);
            } catch (Throwable t) {
                outboundBuffer.failFlushed(t);
            } finally {
                inFlush0 = false;
            }
        }

        protected abstract void doWrite(ChannelOutboundBuffer in) throws Exception;
    ```

    这是要介绍的最后一个模板方法，完成的功能同样还是触发`pipline`对应事件，以及修改异步处理结果。`AbstractChannel.doWrite()`同样是要求子类具体实现。

通过上面的分析，可以发现，`AbstractUnsafe`提供了一系列的模板方法，通过这些模板方法，子类只需要实现网络操作的具体功能，无需关心pipeline事件触发以及异步处理结果响应。注意，所有的`doXXX()`都是在`AbstractChannel`的子类中实现的。
