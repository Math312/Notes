# 5-1. Netty的Channel接口

上一节描述了Channel接口的实现理念，以及与nio中Channel的区别，现在详细探讨Channel接口。

## 1. 接口描述

Channel接口创建了与网络套接字或能够进行I / O操作（例如读取，写入，连接和绑定）的组件的联系。

Channel接口提供给了用户：

1. Channel的当前状态
2. Channel的配置参数
3. Channel支持的I/O操作
4. 处理所有和通道相关联的I/O事件与请求的的ChannelPipeLine。

要注意

1. 所有的Channel操作都是异步的， 这意味着任何I / O调用都将立即返回，而不能保证所请求的I / O操作在调用结束时已完成。但是，当你的I/O操作成功、失败或者被取消时，会返回一个ChannelFuture实例，该实例会帮助你获得结果相关的信息。
2. Channel是分级的，Channel在创建时拥有一个parent。例如，被ServerSocketChannel接受的SocketChannel将返回ServerSocketChannel作为其parent（）的父级。层次结构的语义取决于Channel所属的传输实现。 例如，您可以编写一个新的Channel实现，以创建共享一个套接字连接的子通道，就像BEEP和SSH一样。
3. 一些传输操作需要下调Channel为其子类型，例如，例如，对于旧的I / O数据报传输，DatagramChannel提供了多播join/leave操作。
4. 需要即使释放资源，在使用完Channel后，请务必调用 ChannelOutboundInvoker.close() 或 ChannelOutboundInvoker.close(ChannelPromise)方法，确保资源释放完毕。

方法如下：

方法|描述
---|---
ChannelId id()|获取Channel的全局唯一标识符
EventLoop eventLoop()|返回Channel注册到的EventLoop
Channel parent()|返回Channel的parent，如果parent为空，则返回null
ChannelConfig config()|返回Channel的配置
boolean isOpen()|返回Channel的开闭状态
boolean isRegistered()|返回Channel是否被注册到了EventLoop中
boolean isActive()|如果Channel是活跃的，或者是被连接的，返回true
ChannelMetadata metadata()|返回Channel的元数据
SocketAddress localAddress()|返回此通道绑定到的本地地址。 返回的SocketAddress应该向下转换为更具体的类型，例如InetSocketAddress以检索详细信息。
SocketAddress remoteAddress()|返回此通道连接到的远程地址。 返回的SocketAddress应该向下转换为更具体的类型，例如InetSocketAddress以检索详细信息。
boolean isWritable()|返回当前Channel是否是可写的，如果返回false，则写请求会入队，直到Channel变为可写状态。
Unsafe unsafe()|返回Unsafe对象，该对象用于提供一些内部使用的不安全操作。
ChannelPipeline pipeline()|返回Channel的ChannelPipeLine
ByteBufAllocator alloc()|返回一个ByteBufAllocator，他将为Channel分配ByteBuf
ChannelPromise newPromise()| 返回一个ChannelPromise
ChannelProgressivePromise newProgressivePromise()|返回一个ChannelProgressivePromise
ChannelFuture newSucceededFuture()|返回标记操作成功的ChannelFuture对象。对于这个对象，isSuccess()方法会返回true。添加到其中的所有{@link FutureListener}将直接收到通知。 同样，每次调用阻塞方法都将返回而不阻塞。
ChannelFuture newFailedFuture(Throwable cause)|返回标记操作失败的ChannelFuture对象。对于这个对象，isSuccess()方法会返回false。添加到其中的所有{@link FutureListener}将直接收到通知。 同样，每次调用阻塞方法都将返回而不阻塞。
ChannelPromise voidPromise()| 返回一个无法被其他操作重用的ChannelPromise，他仅仅支持Channel的write(Object,ChannelPromise)方法。请注意，返回的{@link ChannelPromise}将不支持大多数操作，并且仅在要为每个写操作保存对象分配时才应使用。 您将无法检测到操作是否完成，只有在操作失败的情况下，因为在这种情况下，实现将调用{@link ChannelPipeline＃fireExceptionCaught（Throwable）}。请注意，这是一项专家功能，应谨慎使用！
ChannelFuture bind(SocketAddress localAddress)|绑定到给定的SocketAddress，一旦操作完成就会通知ChannelFuture。这将导致ChannelOutboundHandler.bind（ChannelHandlerContext，SocketAddress，SocketAddress，ChannelPromise）方法被调用，该方法调用包含在Channel的ChannelPipeline中的下一个ChannelOutboundHandler。
ChannelFuture connect(SocketAddress remoteAddress)| 请求连接到SocketAddress指定的地址，操作完成后通知ChannelFuture。这将导致ChannelOutboundHandler.connect（ChannelHandlerContext，SocketAddress，SocketAddress，ChannelPromise）方法被调用，该方法调用包含在Channel的ChannelPipeline中的下一个ChannelOutboundHandler。

Channel接口提供的方法可以分为3类：

1. 查询类方法
   1. 查询Channel的配置信息，例如对应的EventLoop，对应的ChannelPipeline。主要有如下方法：
      1. EventLoop eventLoop();
      2. Channel parent();
      3. ChannelConfig config();
      4. ChannelMetadata metadata();
      5. Unsafe unsafe();
      6. ChannelPipeline pipeline();
      7. ByteBufAllocator alloc();
   2. 查询Channel的状态信息，例如channel是否是活跃的，是否可写等。主要有如下方法：
      1. boolean isOpen();
      2. boolean isRegistered();
      3. boolean isActive();
      4. SocketAddress localAddress();
      5. SocketAddress remoteAddress();
      6. boolean isWritable();
2. 操作类方法
    1. 网络操作相关的方法，这类方法主要是处理Channel的网络操作
       1. ChannelFuture bind(SocketAddress localAddress);
       2. ChannelFuture connect(SocketAddress remoteAddress);
       3. ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress);
       4. ChannelFuture disconnect();
       5. ChannelFuture close();
       6. ChannelFuture deregister();
       7. ChannelFuture deregister(ChannelPromise promise);
       8. Channel read();
       9. ChannelFuture write(Object msg);
       10. ChannelFuture write(Object msg, ChannelPromise promise);
       11. Channel flush();
       12. ChannelFuture writeAndFlush(Object msg, ChannelPromise promise);
       13. ChannelFuture writeAndFlush(Object msg);
3. 结果类方法，这类方法主要负责返回异步操作的结果，或者生成结果
   1. ChannelPromise newPromise();
   2. ChannelProgressivePromise newProgressivePromise();
   3. ChannelFuture newSucceededFuture();
   4. ChannelFuture newFailedFuture(Throwable cause);
   5. ChannelPromise voidPromise();

## 2. Unsafe接口

该接口中的方法不应由用户代码进行调用，仅提供这些方法来实现实际的传输，并且必须从I / O线程调用这些方法，以下方法除外：

1. invoker()
2. localAddress()
3. remoteAddress()
4. closeForcibly()
5. register(EventLoop, ChannelPromise)
6. deregister(ChannelPromise)
7. voidPromise()

方法|描述
---|---
RecvByteBufAllocator.Handle recvBufAllocHandle()| 当接受到数据时，使用该方法的返回值分配ByteBuf
ChannelHandlerInvoker invoker()|如果没有刻意指定，则返回默认的ChannelHandlerInvoker
void register(EventLoop eventLoop, ChannelPromise promise)| 注册ChannelPromise的Channel，并且当注册完成时返回ChannelFuture。一旦成功完成{@link ChannelPromise}，从{@link ChannelHandler}内向{@link EventLoop}提交新任务是唯一安全的方法。 否则，任务可能会也可能不会被拒绝。
ChannelOutboundBuffer outboundBuffer()|返回{@link Channel}的{@link ChannelOutboundBuffer}，用于存储写请求的响应

除了上面的方法外，Unsafe接口的许多方法都与`Channel`接口的方法相似，因为`Channel`接口的具体实现大部分都是交给Unsafe的具体实现完成的，这些方法通常都是一些网络操作，我们可以看一下这部分方法：

方法|描述
---|---
SocketAddress localAddress()| 返回localAddress
SocketAddress remoteAddress()|返回remoteAddress
void register(EventLoop eventLoop, ChannelPromise promise);|将Channel注册到EventLoop
void bind(SocketAddress localAddress, ChannelPromise promise);|将Channel绑定到对应的Socket地址
void connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);|连接远程地址
void disconnect(ChannelPromise promise);|断开连接
void close(ChannelPromise promise);|关闭Channel
void closeForcibly();|立即关闭Channel，并且不触发事件
void deregister(ChannelPromise promise);|注销Channel
void beginRead();|从Channel中读取数据
void write(Object msg, ChannelPromise promise);|向输出buffer中写入数据
void flush();|将buffer中的数据刷出到Channel中

接下来让我们看一下`AbstractChannel`对`Channel`的实现，它是`Channel`接口的抽象模板方法。
