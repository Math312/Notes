# NioSocketChannel和NioServerSocketChannel

`NioSocketChannel`是Netty提供的使用Nio的客户端Socket接口，而`NioServerSocketChannel`则是Netty提供的使用Nio的服务端Socket接口。由于服务端相对简单一些，这里我们优先分析负责服务端的`NioServerSocketChannel`。

## NioServerSocketChannel

`NioServerSocketChannel`是`AbstractNioMessageChannel`的子类，在最初讨论`AbstractChannel`时我们曾经留下了一个问题，就是`AbstractChannel.readInterestOp`的具体用处，这里为什么不直接设置成`OP_READ`呢？明明是在`doBeginRead()`中调用的啊：

```java
    protected void doBeginRead() throws Exception {
        if (inputShutdown) {
            return;
        }

        final SelectionKey selectionKey = this.selectionKey;
        if (!selectionKey.isValid()) {
            return;
        }

        readPending = true;

        final int interestOps = selectionKey.interestOps();
        if ((interestOps & readInterestOp) == 0) {
            selectionKey.interestOps(interestOps | readInterestOp);
        }
    }
```

所做的最重要的事情就是把`readInterestOp`注册到Selector中，既然写的是`doBeginRead()`为什么不直接注册`OP_READ`呢？难道除了`OP_READ`，`read()`方法还负责处理其他事件？？

之前讨论`AbstractNioByteChannel`时，我们看到他的构造器是这样的：

```java
protected AbstractNioByteChannel(Channel parent, SelectableChannel ch) {
    super(parent, ch, SelectionKey.OP_READ);
}
```

`readInterestOp`被设置为了`OP_READ`，这点理所应当，也在我们的接受范围之内。现在我们考察一下`NioServerSocketChannel`的构造器：

```java
public NioServerSocketChannel(ServerSocketChannel channel) {
    super(null, channel, SelectionKey.OP_ACCEPT);
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}
```

可以看到，这里`readInterestOp`被设置为了`OP_ACCEPT`,难道`read()`和`beginRead()`方法还处理`OP_ACCEPT`事件，其实，在最早分析的`NioEventLoop`的`processSelectedKey(SelectionKey k, AbstractNioChannel ch)`方法中已经埋下了伏笔：

```java
private static void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
        ...
        try {
            int readyOps = k.readyOps();
            // 注意，这里OP_READ和OP_ACCEPT都触发read()方法
            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
                unsafe.read();
                if (!ch.isOpen()) {
                    // Connection already closed - no need to handle write.
                    return;
                }
            }
            ...
        } catch (CancelledKeyException ignored) {
            unsafe.close(unsafe.voidPromise());
        }
    }
```

那么当新的连接建立时，服务器到底做了什么呢？这个问题，我们会在分析`ServerBootStrap`时进行分析，不过这还需要一段时间。

`AbstractNioMessageChannel`要求子类实现如下两个方法：

```java
protected abstract int doReadMessages(List<Object> buf) throws Exception;
protected abstract boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Exception;
```

这里我们主要看这两个方法的实现：

```java
protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Exception {
    throw new UnsupportedOperationException();
}

protected int doReadMessages(List<Object> buf) throws Exception {
    SocketChannel ch = javaChannel().accept();

    try {
        if (ch != null) {
            buf.add(new NioSocketChannel(this, ch));
            return 1;
        }
    } catch (Throwable t) {
        logger.warn("Failed to create a new channel from an accepted socket.", t);

        try {
            ch.close();
        } catch (Throwable t2) {
            logger.warn("Failed to close a socket.", t2);
        }
    }

    return 0;
}
```

可以看到`NioServerSocketChannel`不支持`doWriteMessage(Object msg, ChannelOutboundBuffer in)`方法，仅仅支持`doReadMessages(List<Object> buf)`方法。这里就引出了两个问题：

1. 为什么`NioServerSocketChannel.doReadMessages(..)`方法读入数据时，读入的竟然是`NioSocketChannel`，而不是具体的数据。
2. 为什么`NioServerSocketChannel`不支持`doWriteMessage(Object msg, ChannelOutboundBuffer in)`，服务端难道不响应请求？？

这里的两个问题，也需要等到讲解`ServerBootStrap`才可以揭晓答案，不过这会很快的，如果想提前了解，可以先看一下`Reactor`，不过本节上面的知识，我想你也可以猜到，这两个问题与`read()`方法的具体处理逻辑有关。

## NioSocketChannel

与`NioServerSocketChannel`相反，`NioSocketChannel`是为客户端提供的`SocketChannel`。值得一提的是，该类覆盖了父类的`doWrite(ChannelOutboundBuffer in)`方法：

```java
    protected void doWrite(ChannelOutboundBuffer in) throws Exception {
        for (;;) {
            int size = in.size();
            // 全部信息都被写入，所以清空OP_WRITE标志
            if (size == 0) {
                clearOpWrite();
                break;
            }
            long writtenBytes = 0;
            boolean done = false;
            boolean setOpWrite = false;

            // 获取当前发送信息的快照
            // 方便刷新数据出去
            // 注意这里的更改会影响到ChannelOutboundBuffer里
            ByteBuffer[] nioBuffers = in.nioBuffers();
            int nioBufferCnt = in.nioBufferCount();
            long expectedWrittenBytes = in.nioBufferSize();
            SocketChannel ch = javaChannel();

            // 根据快照中nioBufferCnt进行数据刷出
            switch (nioBufferCnt) {
                case 0:
                    // 如果ChannelOutboundBuffer中没有数据，则按照原始的功能来
                    super.doWrite(in);
                    return;
                case 1:
                    // 只有一个ByteBuf 直接写到Socket里面
                    ByteBuffer nioBuffer = nioBuffers[0];
                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {
                        final int localWrittenBytes = ch.write(nioBuffer);
                        if (localWrittenBytes == 0) {
                            setOpWrite = true;
                            break;
                        }
                        expectedWrittenBytes -= localWrittenBytes;
                        writtenBytes += localWrittenBytes;
                        if (expectedWrittenBytes == 0) {
                            done = true;
                            break;
                        }
                    }
                    break;
                default:
                    // 如果有很多ByteBuf，那么循环写入
                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {
                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt);
                        if (localWrittenBytes == 0) {
                            setOpWrite = true;
                            break;
                        }
                        expectedWrittenBytes -= localWrittenBytes;
                        writtenBytes += localWrittenBytes;
                        if (expectedWrittenBytes == 0) {
                            done = true;
                            break;
                        }
                    }
                    break;
            }

            // Release the fully written buffers, and update the indexes of the partially written buffer.
            in.removeBytes(writtenBytes);

            if (!done) {
                // 当然最后处理半包问题的方案与之前相同
                incompleteWrite(setOpWrite);
                break;
            }
        }
    }
```

虽然重写了`doWrite(XX)`方法，但是`NioSocketChannel`仍覆盖了`AbstractNioByteChannel`要求的三个方法，这里我们仔细查看一下实现：

```java
    protected int doReadBytes(ByteBuf byteBuf) throws Exception {
        return byteBuf.writeBytes(javaChannel(), byteBuf.writableBytes());
    }

    @Override
    protected int doWriteBytes(ByteBuf buf) throws Exception {
        final int expectedWrittenBytes = buf.readableBytes();
        return buf.readBytes(javaChannel(), expectedWrittenBytes);
    }

    @Override
    protected long doWriteFileRegion(FileRegion region) throws Exception {
        final long position = region.transfered();
        return region.transferTo(javaChannel(), position);
    }
```

其实这三处写操作都使用了零拷贝，上面的`ByteBuf`我们已经知道了，内部就是一个个的`DirectBuffer`，那么`FileRegion`呢？考察`FileRegion.transferTo(XXX)`方法：

```java
    public long transferTo(WritableByteChannel target, long position) throws IOException {
        long count = this.count - position;
        ...
        open();
        // 零拷贝
        long written = file.transferTo(this.position + position, count, target);
        ...
        return written;
    }
```

可以看到，Netty对文件的发送也是走的零拷贝。至此其实我们已经把Netty读取、发送数据的基础全部讲解完毕了。

## 总结

Netty在对性能提升方面做了很多的优化，其中网络IO方面的优化有一点就是使用零拷贝技术，这里已经体现的淋漓尽致，我们通过对EventLoop和Channel的分析，已经将Netty发送读取数据相关的IO方面梳理的相当清晰了，不过还有部分细节未明了，例如ByteBuf的相关细节，ChannelPipeline的相关细节，接下来我们会对其进行分析。
