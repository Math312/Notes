# AbstractByteBuf

上一篇文章介绍了ByteBuf接口要求实现的各个方法，以及完成的功能。`AbstractByteBuf`就是`ByteBuf`的抽象实现。既然是抽象实现，往往与之相关联的就是模板方法与通用属性。

## 属性

根据上一节的功能描述，我们了解到一个ByteBuf至少要有5个属性，`AbstractByteBuf`中的属性，与这个属性的对应关系如下：

ByteBuf|AbstractByteBuf|备注
---|---|---
readerIndex| readerIndex| 读取指针
writerIndex| writerIndex| 写入指针
markedReaderIndex| markedReaderIndex| 被标记的读取指针
markedWriterIndex| markedWriterIndex| 被标注的写入指针
capacity|maxCapacity|ByteBuf的最大容量

事实上除了这5个属性，`AbstractByteBuf`还提供了如下两个属性：

1. swappedBuf
2. leakDetector

这两个属性的用法相对特殊，我们将在后面进行详细分析。不过作为一个ByteBuffer，却没有提供存储数据的容器，例如`byte[]`，想必Netty想将这些细节交给子类完成，那么这就意味着，写入数据、读取数据等与数据相关的方法都要子类实现。

## 方法

在上一节的功能描述中，我们已经将`ByteBuf`要求实现的方法分为7类，接下来我们对这7类方法进行简单分析。

### 1. 基于索引的随机访问

`ByteBuf`提供了`getXXX(int)`和`setXXX(int,Object)`两族方法实现对ByteBuf的随机访问。刚才已经提到，`AbstractByteBuf`没有属性用于存储数据，这个属性将存放在子类中，因此，所有操作数据的操作又要子类实现。因为这个情况，所有`getXXX(int)`和`setXXX(int)`方法事实上都是模板方法。`Netty的ByteBuf`中的习惯是对于模板方法中子类实现的方法均使用`_`开头。

下面使用`getByte(int index)`和`setByte(int index, int value)`举例：

```java
    public byte getByte(int index) {
        // 检测index是否越界
        checkIndex(index);
        return _getByte(index);
    }
    protected final void checkIndex(int index) {
        // 判断ByteBuf是否可用，能访问到
        ensureAccessible();
        // 如果index < 0 或者大于等于 capacity ，数组越界
        if (index < 0 || index >= capacity()) {
            throw new IndexOutOfBoundsException(String.format(
                    "index: %d (expected: range(0, %d))", index, capacity()));
        }
    }
    protected final void ensureAccessible() {
        // 如果引用计数不为0，证明ByteBuf可用
        if (refCnt() == 0) {
            throw new IllegalReferenceCountException(0);
        }
    }
    protected abstract byte _getByte(int index);
```

```java
    public ByteBuf setByte(int index, int value) {
        checkIndex(index);
        _setByte(index, value);
        return this;
    }

    protected abstract void _setByte(int index, int value);
```

可以看到，`getXXX()`和`setXXX()`方法模式都是相同的，调用`checkIndex(index)`校验索引，然后调用对应的`_getXXX()`或`_setXXX()`方法。不过由于很多数据类型占用字节是相同的，因此，Netty做了部分优化，例如Boolean类型就是通过Byte类型的方法实现的：

```java
    public boolean getBoolean(int index) {
        return getByte(index) != 0;
    }
    public ByteBuf setBoolean(int index, boolean value) {
        setByte(index, value ? 1 : 0);
        return this;
    }
```

下面这张表给出了数据类型之间的关联情况：

原数据类型|实现数据类型|原因
---|---|---
Boolean|Byte|byte数据为1，表示true，为0，表示false
UnsignedByte|Byte|byte数据& 0xFF，强转为short，因为short为两个字节，byte & 0xFF后必定为正数，因为符号位位与操作置为0了
UnsignedShort|Short|short数据& 0xFFFF，为Integer类型，因为Integer为两个字节，short & 0xFFFF后必定为正数，因为符号位位与操作置为0了
Medium|UnsignedMedium|原数据先位与一下0x800000，因为Medium是24位，先判断数据的符号位是否为0，如果不是，则位或0xff000000，补上符号位
UnsignedInt|Int|getInt(index)方法返回的值是int与身为Long值的0xFFFFFFFFL进行了与操作后就会变为Long，符号位被全部置为0了。
Char|Short|Char和Short，大家都是两字节
Float|Int|Float和Integer一样是4字节
Double|Long|double和Long都是8字节

事实上，在`AbstractByteBuf`中几乎所有数据操作都遵循上表，例如`write`和`read`族方法：

```java
    public ByteBuf writeBoolean(boolean value) {
        writeByte(value ? 1 : 0);
        return this;
    }

    @Override
    public ByteBuf writeByte(int value) {
        // 确保ByteBuf是可用的
        ensureAccessible();
        // 确保ByteBuf可以写入一个字节
        ensureWritable(1);
        // 将value写入到ByteBuf中
        _setByte(writerIndex++, value);
        return this;
    }

    public ByteBuf ensureWritable(int minWritableBytes) {
        if (minWritableBytes < 0) {
            throw new IllegalArgumentException(String.format(
                    "minWritableBytes: %d (expected: >= 0)", minWritableBytes));
        }
        // 判断剩余空间是否足够
        if (minWritableBytes <= writableBytes()) {
            return this;
        }
        // 如果不够，则报错IndexOutOfBoundsException
        if (minWritableBytes > maxCapacity - writerIndex) {
            throw new IndexOutOfBoundsException(String.format(
                    "writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s",
                    writerIndex, minWritableBytes, maxCapacity, this));
        }

        // 
        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);

        // Adjust to the new capacity.
        capacity(newCapacity);
        return this;
    }

    public int writableBytes() {
        return capacity() - writerIndex;
    }
```

```java
    public byte readByte() {
        checkReadableBytes(1);
        int i = readerIndex;
        byte b = getByte(i);
        readerIndex = i + 1;
        return b;
    }

    @Override
    public boolean readBoolean() {
        return readByte() != 0;
    }

    protected final void checkReadableBytes(int minimumReadableBytes) {
        ensureAccessible();
        if (minimumReadableBytes < 0) {
            throw new IllegalArgumentException("minimumReadableBytes: " + minimumReadableBytes + " (expected: >= 0)");
        }
        if (readerIndex > writerIndex - minimumReadableBytes) {
            throw new IndexOutOfBoundsException(String.format(
                    "readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s",
                    readerIndex, minimumReadableBytes, writerIndex, this));
        }
    }
```
