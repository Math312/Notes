# ByteBuf

对于网络开发来说，数据传输时无论如何都离不开缓冲区，ByteBuf起到的功能就是如此。Java NIO里面起到该作用的就是`java.nio.Buffer`，但是由于`java.nio.Buffer`有一定的局限性，所以Netty实现了自己的`ByteBuf`。`java.nio.Buffer`的局限性如下：

1. ByteBuffer长度固定，一旦分配完成，它的容量不能动态收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生越界异常
2. ByteBuffer只有一个标识位置的指针position，读写时必须手工调用flip()和rewind()等。
3. ByteBuffer的API功能支持有限，一些高级特性不支持，需要使用者自己编程。

接下来我们将结合`ByteBuf`的文档，介绍ByteBuf的特性。

## 1. 基于索引的随机访问

ByteBuf可以像数组一样，提供基于索引的随机访问，就像数组A可以通过A[0]访问它的第一个元素一样，ByteBuf可以通过一系列的get、set方法对ByteBuf进行随机访问。

实现这个功能的方法有两组，负责实现读取功能的方法都以`get开头`，负责实现设置功能的方法都以`set开头`。由于ByteBuf可以用于管理各种类型的数据，因此，这两组方法就负责分别管理各种数据的读写操作，例如`getByte(int index)`就`负责获取index索引位置对应的字节所保存的数据`，这个方法对应的`setByte(int index, int value)`则负责`将index索引位置对应的字节设置为value保存的值`。

`ByteBuf`管理了如下几种类型的数据：

1. Byte
2. Byte[]
3. Char
4. Double
5. Float
6. Int
7. Long
8. Medium：24位长度的整形数字
9. Short
10. Zero：NULL(0x00)

由支持的数据类型，可见 ByteBuf的强大，如果使用`java.nio.ByteBuffer`则要将其转化为对应的`XXXBuffer`才能执行对应的操作，麻烦许多。

## 2. 双指针索引

`java.nio.ByteBuffer`提供了一个position指针用于标记`ByteBuffer`的操作位置，然而由于在读取和写入时，可能要不断切换`position`位置，来保证写入读取操作的正确性，十分麻烦，因此`ByteBuf`提供了两个指针`readerIndex`和`writerIndex`分别表示`读操作指针`和`写操作指针`。

两个指针的大致状态如下：

```java
        +-------------------+------------------+------------------+
        | discardable bytes |  readable bytes  |  writable bytes  |
        |                   |     (CONTENT)    |                  |
        +-------------------+------------------+------------------+
        |                   |                  |                  |
        0      <=      readerIndex   <=   writerIndex    <=    capacity
```

其中`[0,readerIndex)`表示已读数据，`[0,writerIndex)`表示已经写数据，`[writerIndex,capacity]`表示剩余空间。

注意，上一部分提到的所有`get`和`set`两组方法均不会更改`readerIndex`和`writerIndex`，通常只有在读写数据时，才会修改这两个索引。ByteBuf提供了`read`和`write`两组方法来实现对`ByteBuf`的读写操作。这两组方法操作的数据类型与`get`和`set`方法相同。

其中`read`族方法会将数据从ByteBuf的`readerIndex`开始读取，根据读取方法操作的数据类型读取完数据后，将`readerIndex`右移。，`write`族方法会将数据写入ByteBuf到`writerIndex`的未知，并且将`writerIndex`右移一定距离。这里拿`readByte()`和`writeByte()`举例，现在有一个空的`ByteBuf`。

```java
-----------------
|   |   |   |   |
-----------------
|
readerIndex
writerIndex
```

这是一个`capacity`为4的数组，`readerIndex`和`writerIndex`都为0，那么如果调用了`writeByte(1)`，那么ByteBuf就会变为如下形式：

```java
-----------------
| 1 |   |   |   |
-----------------
|   |
|  writerIndex
readerIndex
```

可以看到数据写入了`writerIndex`的位置，并且`writerIndex += 1`了。这时候如果调用`readByte()`，那么ByteBuf会变为如下形式：

```java
-----------------
| 1 |   |   |   |
-----------------
    |
    writerIndex
    readerIndex
```

由于`readerIndex`原来的值是0，因此`ByteBuf[0]`上的数据`1`，被读取出来，并且将`readerIndex+=1`。

但是ByteBuf有一个规定，就是使用者只能读取写入了的数据，也就是`readerIndex<= writerIndex <= capacity`这个条件必须成立，如果有造成该条件不成立的操作，就会抛出异常。例如，我们继续讨论上面的`ByteBuf`，如果此时我们继续调用`readByte()`方法，这时，由于`readerIndex和writerIndex之间没有数据了`，如果读取数据会导致`readerIndex>writerIndex`，所以就会抛出`IndexOutOfBoundsException`。如果`writerIndex>capacity`也会抛出该异常。

既然有更新`readerIndex`和`writerIndex`的方法，就有重置这两个索引的方法，该方法就是`clear()`方法。

## 3.支持查询操作

就像字符串一样，`ByteBuf`提供了一系列类似于`indexOf(int fromIndex, int toIndex, byte value)`的操作用于在`fromIndex 到 toIndex之间查找第一个值为value的数据的索引`。

有时我们希望仅仅在`ByteBuf`中保存的未读数据中进行查找，为了达到该目的，`ByteBuf`提供了`bytesBefore(byte value)`和`bytesBefore(int length, byte value)`这两个方法，后者提供了一个查询范围的限制。需要注意这两个方法的查找范围都是`[readerIndex,writerIndex)`。

有些时候，我们的查找条件比较特殊，并不是仅仅一个相等就能解决的，所以`ByteBuf`还提供了4个用于遍历`ByteBuf`进行查找的方法：

1. public abstract int forEachByte(ByteBufProcessor processor);
2. public abstract int forEachByte(int index, int length, ByteBufProcessor processor);
3. public abstract int forEachByteDesc(ByteBufProcessor processor);
4. public abstract int forEachByteDesc(int index, int length, ByteBufProcessor processor);

前两者是从前往后遍历`ByteBuf`，后两者相反，为了提供自定义的查找逻辑，`ByteBuf`提供了`ByteBufProcessor`接口，代码如下：

```java
public interface ByteBufProcessor {
        boolean process(byte value) throws Exception;
}
```

该接口只要求实现`process(byte)`方法，该方法返回boolean值，用于标识遍历结果，如果返回结果为false，就停止循环将索引返回给调用端。

由于上面介绍的所有方法都用于查询，因此他们完全不会修改`readerIndex`和`writerIndex`。

## 4.标记和重置索引

由于有些时候我们希望对某个`ByteBuf`进行读操作，处理完之后再读一次，写操作同理，因此这时就需要先将`readerIndex`和`writerIndex`先记录下来，然后进行操作，最后再将`readerIndex`和`writerIndex`重置。

为了完成这个功能，ByteBuf提供了如下4个方法：

1. public abstract ByteBuf markReaderIndex()
2. public abstract ByteBuf resetReaderIndex();
3. public abstract ByteBuf markWriterIndex();
4. public abstract ByteBuf resetWriterIndex();

## 5.切片、拷贝操作

对于Python、Golang这类语言来说，语法里面默认都支持一类叫做切片的操作，而Java的数组里面没有，但是确实相当方便。`ByteBuf`实现了这个功能，通过如下几个方法：

1. public abstract ByteBuf duplicate()：复制整个ByteBuf
2. public abstract ByteBuf slice()：返回当前ByteBuf中可读数据的切片
3. public abstract ByteBuf slice(int index, int length)：通过索引和长度进行切片

就像python这类语言一样，用上面方法生成的切片，在被修改时会映射到原ByteBuf上。如果想要一个深拷贝的ByteBuf，可以调用如下两个方法：

1. public abstract ByteBuf copy(); 创建可读数据的深拷贝
2. public abstract ByteBuf copy(int index, int length)：通过索引和长度拷贝数据

## 6.转化为JDK数据类型

无论Netty如何封装，最底层都是通过JDK提供的API进行交互（Netty原生实现除外），ByteBuf可以轻松的转化为如下三类数据：

1. Byte Array： array()
2. NIO Buffer： nioBuffer()
3. String：toString()
4. IO Stream：ByteInputStream和ByteOutputStream

## 7. 基于引用计数的对象管理

ByteBuf用于作为缓冲区，要被经常的循环利用，但是为了避免多次重复分配、销毁对象带来的性能损耗，Netty使用了池化思想来管理缓存，但是这面临着一个问题，ByteBuf是否还在被其他对象使用。

处理这种问题最容易想到的方法就是引用计数法，因此，ByteBuf还继承了一个接口`ReferenceCounted`，该接口就负责处理引用计数的功能。

该接口主要要求实现5个方法：

1. int refCnt()：该方法负责返回引用该对象的对象数量，如果返回值为0，那么表示该对象已经被释放
2. ReferenceCounted retain()：引用计数+1
3. ReferenceCounted retain(int increment)：引用计数+`increment`
4. boolean release()：引用计数-1
5. boolean release(int decrement)：引用计数-`decrement`

实例化一个新的`ReferenceCounted`时，它以1的引用计数开始，当调用`release`方法将引用计数降为0时，对象也会被释放。

## 总结

本节介绍了ByteBuf接口要求实现类实现的所有功能，以及相关的API接口。ByteBuf为了开发者方便要求实现了如下功能：

1. 基于索引的随机访问：ByteBuffer仅支持读取、写入数据的访问，不支持随机访问
2. 双指针索引：ByteBuffer只有一个position指针
3. 支持查询操作：ByteBuffer并不支持该操作，只能读取出数据自己实现
4. 标记和重置索引
5. 切片、拷贝操作：ByteBuffer并不支持该操作，只能读取出数据自己实现
6. 转化为JDK数据类型
7. 基于引用计数的对象管理

但是这仅仅是实现规范，具体实现我们仍要去具体分析ByteBuf的具体实现，这部分的分析从下节开始。
