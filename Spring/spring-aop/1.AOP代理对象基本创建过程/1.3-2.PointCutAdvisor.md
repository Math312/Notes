# PointAdvisor

该接口是所有基于PointCut的Advisor的父类接口，这几乎涵盖了除介绍Introduction Advisor以外的所有Advisor，这些Advisor（指Introduction Advisor）不适用于方法级别的匹配。

这里我们考虑PointAdvisor源码，之后再考虑IntroductionAdvisor。

## 要求实现方法

该接口要求实现的方法只有一个，getPointcut()，代码如下：

```java
/**
 * Get the Pointcut that drives this advisor.
 */
Pointcut getPointcut();
```

该方法很简单，仅仅用于获取Advisor对应的Pointcut。考虑Pointcut接口源码：

```java
/**
 * Core Spring pointcut abstraction.
 *
 * Spring切面的核心抽象。
 *
 * <p>A pointcut is composed of a {@link ClassFilter} and a {@link MethodMatcher}.
 * 一个Pointcut是ClassFilter和MethodMatcher的组合。
 * Both these basic terms and a Pointcut itself can be combined to build up combinations
 * (e.g. through {@link org.springframework.aop.support.ComposablePointcut}).
 *
 * 这些基本术语和Pointcut本身都可以组合起来以建立组合（例如，通过ComposablePointcut）。
 * @author Rod Johnson
 * @see ClassFilter
 * @see MethodMatcher
 * @see org.springframework.aop.support.Pointcuts
 * @see org.springframework.aop.support.ClassFilters
 * @see org.springframework.aop.support.MethodMatchers
 */
```

所以可以看出，由于Pointcut包含了ClassFilter和MethodMatcher，所以可以进行方法级别的匹配。该接口要求实现的方法也只有getClassFilter()和getMethodMatcher()两种。默认给了一个实现：

```java
Pointcut TRUE = TruePointcut.INSTANCE;
```

该实现对于无论什么输入都返回true。

顺便考察一下IntroductionAdvisor接口源码，可以看到它要求实现的方法只有如下几个：

```java
ClassFilter getClassFilter();
void validateInterfaces() throws IllegalArgumentException;
```

这也就是为什么它不支持方法级别匹配的原因。
