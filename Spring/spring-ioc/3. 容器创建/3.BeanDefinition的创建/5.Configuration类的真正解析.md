# 5.Configuration类的真正解析

上一节已经提到，Configuration类的真正解析逻辑由`doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)`完成，本节主要考虑该方法。

该方法主要处理了7部分逻辑，分别是：

1. 解析配置类中的内部类
2. 解析PropertySources注解
3. 解析ComponentScan注解
4. 解析Import注解
5. 处理ImportResource注解
6. 解析Bean注解
7. 解析配置类的父类

接下来我们对上述七步依次分析。

## 5.1 解析内部类

由于Java语法支持内部类，因此配置类也允许有内部类，考虑处理配置类内部类的逻辑：

```java
if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
    // 处理内部类
    processMemberClasses(configClass, sourceClass);
}
```

由于`@Configuration`注解本身就包含`@Component`注解，因此一般的配置类中的内部类都会被处理，但是有一些是没有被`@Component`注解修饰的，例如被`@Import`修饰的配置类。下面我们考虑一下配置类中的内部类是如何被处理的，考察`processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass)`方法:

```java
private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {
    // 获取内部类集合的SourceClass集合
    Collection<SourceClass> memberClasses = sourceClass.getMemberClasses();
    if (!memberClasses.isEmpty()) {
        // 如果存在内部类
        // 创建一个List<SourceClass>用于存储内部类中可用的候选配置
        List<SourceClass> candidates = new ArrayList<>(memberClasses.size());
        // 遍历所有内部类
        for (SourceClass memberClass : memberClasses) {
            // 判断内部类是否是一个可用的候选配置
            if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&
                !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {
                // 如果是，则加入candidates中
                candidates.add(memberClass);
            }
        }
        // 为内部类中所有可用的候选配置按Order接口排序
        OrderComparator.sort(candidates);
        // 遍历每个可用的内部类配置
        // 递归调用processConfigurationClass方法解析配置类
        for (SourceClass candidate : candidates) {
            // 处理循环依赖问题
            if (this.importStack.contains(configClass)) {
                this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
            }
            else {
                this.importStack.push(configClass);
                try {
                    processConfigurationClass(candidate.asConfigClass(configClass));
                }
                finally {
                    this.importStack.pop();
                }
            }
        }
    }
}
```

处理配置类的内部类的逻辑很简单，只是简单的将这些内部类将配置类对待罢了，但是考察上述代码引出了一个问题，即配置的循环依赖问题。Spring是如何处理这个问题的呢？事实证明在解析某个配置类之前，他将即将解析的配置类放入到`importStack`属性中，然后在进行解析，解析完成后将配置类从`importStack`中弹出。如果在解析过程中重复解析到某个类，证明出现了`Import`注解带来的循环依赖。

那到底如何判断该类是一个配置类呢？该判断逻辑在`ConfigurationClassUtils`的`isConfigurationCandidate(AnnotationMetadata metadata)`方法中，考察该方法：

```java
public static boolean isConfigurationCandidate(AnnotationMetadata metadata) {
    // 如果传入的是接口，则直接返回false
    // 因为接口不是配置类
    if (metadata.isInterface()) {
        return false;
    }

    // 如果传入的类信息被candidateIndicators指定的注解修饰，则返回True
    // 默认情况下有：Component、ComponentScan、Import、ImportResource
    // 上述四个注解
    for (String indicator : candidateIndicators) {
        if (metadata.isAnnotated(indicator)) {
            return true;
        }
    }

    // 最后，如果有@Bean修饰的方法则返回True
    try {
        return metadata.hasAnnotatedMethods(Bean.class.getName());
    }
    catch (Throwable ex) {
        if (logger.isDebugEnabled()) {
            logger.debug("Failed to introspect @Bean methods on class [" + metadata.getClassName() + "]: " + ex);
        }
        return false;
    }
}
```

通过上面的步骤，所有可以被当做配置类的内部类就已经被解析完成了。

## 5.2 处理PropertySource注解

Spring提供了`PropertySource`注解用于加载指定位置的属性文件，`doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)`方法使用如下代码对该注解进行处理：

```java
// 遍历修饰当前解析配置类的所有PropertySources注解和PropertySource属性
for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
    sourceClass.getMetadata(), PropertySources.class,
    org.springframework.context.annotation.PropertySource.class)) {
    // 如果传入的`this.environment`适可配置的，那么开始处理这些属性
    if (this.environment instanceof ConfigurableEnvironment) {
        processPropertySource(propertySource);
    }
    else {
        logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +
            "]. Reason: Environment must implement ConfigurableEnvironment");
    }
}
```

可以看到处理`PropertySource`注解的方法在`processPropertySource(AnnotationAttributes propertySource)`中，下面考察该方法：

```java
private void processPropertySource(AnnotationAttributes propertySource) throws IOException {
    String name = propertySource.getString("name");
    if (!StringUtils.hasLength(name)) {
        name = null;
    }
    String encoding = propertySource.getString("encoding");
    if (!StringUtils.hasLength(encoding)) {
        encoding = null;
    }
    String[] locations = propertySource.getStringArray("value");
    Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required");
    boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound");

    Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory");
    PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?
        DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));

    for (String location : locations) {
        try {
            String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);
            Resource resource = this.resourceLoader.getResource(resolvedLocation);
            addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));
        }
        catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {
            // Placeholders not resolvable or resource not found when trying to open it
            if (ignoreResourceNotFound) {
                if (logger.isInfoEnabled()) {
                    logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage());
                }
            }
            else {
                throw ex;
            }
        }
    }
}
```
