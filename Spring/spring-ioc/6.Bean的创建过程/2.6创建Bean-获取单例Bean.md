# 2.6创建Bean-真正开始创建bean

由于创建的bean是单例，所以可以进行缓存，其余Scope则不行，这里再一次从缓存中获取：

```java
synchronized (this.singletonObjects) {
    Object singletonObject = this.singletonObjects.get(beanName);
    ...
}
```

这里使用同步描述符限制也因此不无道理，如果`singletonObject`不为空，那么直接返回，否则，开始创建新的bean，这里开始考察创建bean的方法，这里又是一个模板方法：

首先判断BeanFactory是否在销毁bean，Spring不允许销毁bean的同时创建bean:

```java
if (this.singletonsCurrentlyInDestruction) {
    throw new BeanCreationNotAllowedException(beanName,
        "Singleton bean creation not allowed while singletons of this factory are in destruction " +
        "(Do not request a bean from a BeanFactory in a destroy method implementation!)");
}
```

在创建bean之前，需要记录beanName，标识某些bean正在创建，这也用于循环依赖检查：

```java
beforeSingletonCreation(beanName);
```

考察该方法：

```java
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
```

该方法与`this.inCreationCheckExclusions`与`this.singletonsCurrentlyInCreation`属性相关，考察两个属性：

```java
/** Names of beans currently excluded from in creation checks. */
/** 创建过程中不需要检查的bean名称 */
private final Set<String> inCreationCheckExclusions =
    Collections.newSetFromMap(new ConcurrentHashMap<>(16));

/** Names of beans that are currently in creation. */
/** 正在创建的bean名称 */
private final Set<String> singletonsCurrentlyInCreation =
    Collections.newSetFromMap(new ConcurrentHashMap<>(16));
```

再次考察`beforeSingletonCreation(String beanName)`方法：

```java
protected void beforeSingletonCreation(String beanName) {
    /** 如果bean创建过程中需要进行检查，并且该bean在创建过程中，那么抛出异常 */
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
```

这里我们考察一下抛出的异常`BeanCurrentlyInCreationException`:

```java
public BeanCurrentlyInCreationException(String beanName) {
    super(beanName,
        "Requested bean is currently in creation: Is there an unresolvable circular reference?");
}
```

根据`message`，可以知道，该Bean表示循环依赖。所以上述的判断条件又是处理循环依赖的。如果该bean在创建过程中再次创建该bean，表示具有循环依赖。

创建bean之前还初始化了两个参数，分别如下：

```java
boolean newSingleton = false;
boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
if (recordSuppressedExceptions) {
    this.suppressedExceptions = new LinkedHashSet<>();
}
```

该参数分别表示如下含义：

1. newSingleton: 表示单例是否是新创建的
2. recordSuppressedExceptions：该属性用于记录bean创建过程中的exception

接下来开始讨论真正创建bean的逻辑，`AbstractBeanFactory`中调用`getSingleton(String beanName, ObjectFactory<?> singletonFactory)`方法时，调用代码如下：

```java
sharedInstance = getSingleton(beanName, () -> {
    try {
        return createBean(beanName, mbd, args);
    }
    catch (BeansException ex) {
        // Explicitly remove instance from singleton cache: It might have been put there
        // eagerly by the creation process, to allow for circular reference resolution.
        // Also remove any beans that received a temporary reference to the bean.
        destroySingleton(beanName);
        throw ex;
    }
});
```

查看`getSingleton(String beanName, ObjectFactory<?> singletonFactory)`方法代码中真正创建bean的逻辑可以发现，正是调用ObjectFactory的getObject()方法创建：

```java
try {
    // 创建单例对象
    singletonObject = singletonFactory.getObject();
    // 标识单例是新创建的
    newSingleton = true;
}
catch (IllegalStateException ex) {
    // 如果在异常产生之前，产生了默认的单例对象，那么就使用默认的单例对象
    singletonObject = this.singletonObjects.get(beanName);
    // 如果单例对象都没有，则抛出异常
    if (singletonObject == null) {
        throw ex;
    }
}
catch (BeanCreationException ex) {
    // 记录异常进行处理
    if (recordSuppressedExceptions) {
        for (Exception suppressedException : this.suppressedExceptions) {
            ex.addRelatedCause(suppressedException);
        }
    }
    throw ex;
}
finally {
    // 将异常记录对象清空
    if (recordSuppressedExceptions) {
        this.suppressedExceptions = null;
    }
    // 清除正在创建bean的标识
    afterSingletonCreation(beanName);
}
if (newSingleton) {
    // 将新创建的单例加入到缓存
    addSingleton(beanName, singletonObject);
}
```

这里详细考察一下`afterSingletonCreation(String beanName)`函数，该函数与`beforeSingletonCreation(String beanName)`，代码如下：

```java
protected void afterSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.remove(beanName)) {
        throw new IllegalStateException("Singleton '" + beanName + "' isn't currently in creation");
    }
}
```

这里的操作也仅仅是将放入`this.singletonsCurrentlyInCreation`中的beanName移除，然而这就足以进行判断循环依赖。

截止至此，新的bean已经创建完成，此时需要将bean放入缓存中，这部分逻辑在`addSingleton(String beanName, Object singletonObject)`函数中，代码逻辑如下：

```java
protected void addSingleton(String beanName, Object singletonObject) {
    synchronized (this.singletonObjects) {
        this.singletonObjects.put(beanName, singletonObject);
        this.singletonFactories.remove(beanName);
        this.earlySingletonObjects.remove(beanName);
        this.registeredSingletons.add(beanName);
    }
}
```
